/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@polymer/polymer/lib/elements/dom-if.js":
/*!**************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/elements/dom-if.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DomIf = undefined;\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _polymerElement = __webpack_require__(/*! ../../polymer-element.js */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n\nvar _templatize = __webpack_require__(/*! ../utils/templatize.js */ \"./node_modules/@polymer/polymer/lib/utils/templatize.js\");\n\nvar _debounce = __webpack_require__(/*! ../utils/debounce.js */ \"./node_modules/@polymer/polymer/lib/utils/debounce.js\");\n\nvar _flush = __webpack_require__(/*! ../utils/flush.js */ \"./node_modules/@polymer/polymer/lib/utils/flush.js\");\n\nvar _async = __webpack_require__(/*! ../utils/async.js */ \"./node_modules/@polymer/polymer/lib/utils/async.js\");\n\nvar _path = __webpack_require__(/*! ../utils/path.js */ \"./node_modules/@polymer/polymer/lib/utils/path.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * The `<dom-if>` element will stamp a light-dom `<template>` child when\n * the `if` property becomes truthy, and the template can use Polymer\n * data-binding and declarative event features when used in the context of\n * a Polymer element's template.\n *\n * When `if` becomes falsy, the stamped content is hidden but not\n * removed from dom. When `if` subsequently becomes truthy again, the content\n * is simply re-shown. This approach is used due to its favorable performance\n * characteristics: the expense of creating template content is paid only\n * once and lazily.\n *\n * Set the `restamp` property to true to force the stamped content to be\n * created / destroyed when the `if` condition changes.\n *\n * @customElement\n * @polymer\n * @extends Polymer.Element\n * @memberof Polymer\n * @summary Custom element that conditionally stamps and hides or removes\n *   template content based on a boolean flag.\n */\nvar DomIf = function (_PolymerElement) {\n  _inherits(DomIf, _PolymerElement);\n\n  _createClass(DomIf, null, [{\n    key: 'is',\n\n\n    // Not needed to find template; can be removed once the analyzer\n    // can find the tag name from customElements.define call\n    get: function get() {\n      return 'dom-if';\n    }\n  }, {\n    key: 'template',\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: 'properties',\n    get: function get() {\n\n      return {\n\n        /**\n         * Fired whenever DOM is added or removed/hidden by this template (by\n         * default, rendering occurs lazily).  To force immediate rendering, call\n         * `render`.\n         *\n         * @event dom-change\n         */\n\n        /**\n         * A boolean indicating whether this template should stamp.\n         */\n        if: {\n          type: Boolean,\n          observer: '__debounceRender'\n        },\n\n        /**\n         * When true, elements will be removed from DOM and discarded when `if`\n         * becomes false and re-created and added back to the DOM when `if`\n         * becomes true.  By default, stamped elements will be hidden but left\n         * in the DOM when `if` becomes false, which is generally results\n         * in better performance.\n         */\n        restamp: {\n          type: Boolean,\n          observer: '__debounceRender'\n        }\n\n      };\n    }\n  }]);\n\n  function DomIf() {\n    _classCallCheck(this, DomIf);\n\n    var _this = _possibleConstructorReturn(this, (DomIf.__proto__ || Object.getPrototypeOf(DomIf)).call(this));\n\n    _this.__renderDebouncer = null;\n    _this.__invalidProps = null;\n    _this.__instance = null;\n    _this._lastIf = false;\n    _this.__ctor = null;\n    return _this;\n  }\n\n  _createClass(DomIf, [{\n    key: '__debounceRender',\n    value: function __debounceRender() {\n      var _this2 = this;\n\n      // Render is async for 2 reasons:\n      // 1. To eliminate dom creation trashing if user code thrashes `if` in the\n      //    same turn. This was more common in 1.x where a compound computed\n      //    property could result in the result changing multiple times, but is\n      //    mitigated to a large extent by batched property processing in 2.x.\n      // 2. To avoid double object propagation when a bag including values bound\n      //    to the `if` property as well as one or more hostProps could enqueue\n      //    the <dom-if> to flush before the <template>'s host property\n      //    forwarding. In that scenario creating an instance would result in\n      //    the host props being set once, and then the enqueued changes on the\n      //    template would set properties a second time, potentially causing an\n      //    object to be set to an instance more than once.  Creating the\n      //    instance async from flushing data ensures this doesn't happen. If\n      //    we wanted a sync option in the future, simply having <dom-if> flush\n      //    (or clear) its template's pending host properties before creating\n      //    the instance would also avoid the problem.\n      this.__renderDebouncer = _debounce.Debouncer.debounce(this.__renderDebouncer, _async.microTask, function () {\n        return _this2.__render();\n      });\n      (0, _flush.enqueueDebouncer)(this.__renderDebouncer);\n    }\n\n    /**\n     * @return {void}\n     */\n\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      _get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'disconnectedCallback', this).call(this);\n      if (!this.parentNode || this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !this.parentNode.host) {\n        this.__teardownInstance();\n      }\n    }\n\n    /**\n     * @return {void}\n     */\n\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      _get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'connectedCallback', this).call(this);\n      this.style.display = 'none';\n      if (this.if) {\n        this.__debounceRender();\n      }\n    }\n\n    /**\n     * Forces the element to render its content. Normally rendering is\n     * asynchronous to a provoking change. This is done for efficiency so\n     * that multiple changes trigger only a single render. The render method\n     * should be called if, for example, template rendering is required to\n     * validate application state.\n     * @return {void}\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      (0, _flush.flush)();\n    }\n  }, {\n    key: '__render',\n    value: function __render() {\n      if (this.if) {\n        if (!this.__ensureInstance()) {\n          // No template found yet\n          return;\n        }\n        this._showHideChildren();\n      } else if (this.restamp) {\n        this.__teardownInstance();\n      }\n      if (!this.restamp && this.__instance) {\n        this._showHideChildren();\n      }\n      if (this.if != this._lastIf) {\n        this.dispatchEvent(new CustomEvent('dom-change', {\n          bubbles: true,\n          composed: true\n        }));\n        this._lastIf = this.if;\n      }\n    }\n  }, {\n    key: '__ensureInstance',\n    value: function __ensureInstance() {\n      var _this3 = this;\n\n      var parentNode = this.parentNode;\n      // Guard against element being detached while render was queued\n      if (parentNode) {\n        if (!this.__ctor) {\n          var template = /** @type {HTMLTemplateElement} */this.querySelector('template');\n          if (!template) {\n            // Wait until childList changes and template should be there by then\n            var observer = new MutationObserver(function () {\n              if (_this3.querySelector('template')) {\n                observer.disconnect();\n                _this3.__render();\n              } else {\n                throw new Error('dom-if requires a <template> child');\n              }\n            });\n            observer.observe(this, { childList: true });\n            return false;\n          }\n          this.__ctor = (0, _templatize.templatize)(template, this, {\n            // dom-if templatizer instances require `mutable: true`, as\n            // `__syncHostProperties` relies on that behavior to sync objects\n            mutableData: true,\n            /**\n             * @param {string} prop Property to forward\n             * @param {*} value Value of property\n             * @this {this}\n             */\n            forwardHostProp: function forwardHostProp(prop, value) {\n              if (this.__instance) {\n                if (this.if) {\n                  this.__instance.forwardHostProp(prop, value);\n                } else {\n                  // If we have an instance but are squelching host property\n                  // forwarding due to if being false, note the invalidated\n                  // properties so `__syncHostProperties` can sync them the next\n                  // time `if` becomes true\n                  this.__invalidProps = this.__invalidProps || Object.create(null);\n                  this.__invalidProps[(0, _path.root)(prop)] = true;\n                }\n              }\n            }\n          });\n        }\n        if (!this.__instance) {\n          this.__instance = new this.__ctor();\n          parentNode.insertBefore(this.__instance.root, this);\n        } else {\n          this.__syncHostProperties();\n          var c$ = this.__instance.children;\n          if (c$ && c$.length) {\n            // Detect case where dom-if was re-attached in new position\n            var lastChild = this.previousSibling;\n            if (lastChild !== c$[c$.length - 1]) {\n              for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {\n                parentNode.insertBefore(n, this);\n              }\n            }\n          }\n        }\n      }\n      return true;\n    }\n  }, {\n    key: '__syncHostProperties',\n    value: function __syncHostProperties() {\n      var props = this.__invalidProps;\n      if (props) {\n        for (var prop in props) {\n          this.__instance._setPendingProperty(prop, this.__dataHost[prop]);\n        }\n        this.__invalidProps = null;\n        this.__instance._flushProperties();\n      }\n    }\n  }, {\n    key: '__teardownInstance',\n    value: function __teardownInstance() {\n      if (this.__instance) {\n        var c$ = this.__instance.children;\n        if (c$ && c$.length) {\n          // use first child parent, for case when dom-if may have been detached\n          var parent = c$[0].parentNode;\n          for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {\n            parent.removeChild(n);\n          }\n        }\n        this.__instance = null;\n        this.__invalidProps = null;\n      }\n    }\n\n    /**\n     * Shows or hides the template instance top level child elements. For\n     * text nodes, `textContent` is removed while \"hidden\" and replaced when\n     * \"shown.\"\n     * @return {void}\n     * @protected\n     */\n\n  }, {\n    key: '_showHideChildren',\n    value: function _showHideChildren() {\n      var hidden = this.__hideTemplateChildren__ || !this.if;\n      if (this.__instance) {\n        this.__instance._showHideChildren(hidden);\n      }\n    }\n  }]);\n\n  return DomIf;\n}(_polymerElement.PolymerElement);\n\ncustomElements.define(DomIf.is, DomIf);\n\nexports.DomIf = DomIf;\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/elements/dom-if.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/elements/dom-module.js":
/*!******************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/elements/dom-module.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DomModule = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n\nvar _resolveUrl = __webpack_require__(/*! ../utils/resolve-url.js */ \"./node_modules/@polymer/polymer/lib/utils/resolve-url.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar modules = {};\nvar lcModules = {};\nfunction findModule(id) {\n  return modules[id] || lcModules[id.toLowerCase()];\n}\n\nfunction styleOutsideTemplateCheck(inst) {\n  if (inst.querySelector('style')) {\n    console.warn('dom-module %s has style outside template', inst.id);\n  }\n}\n\n/**\n * The `dom-module` element registers the dom it contains to the name given\n * by the module's id attribute. It provides a unified database of dom\n * accessible via its static `import` API.\n *\n * A key use case of `dom-module` is for providing custom element `<template>`s\n * via HTML imports that are parsed by the native HTML parser, that can be\n * relocated during a bundling pass and still looked up by `id`.\n *\n * Example:\n *\n *     <dom-module id=\"foo\">\n *       <img src=\"stuff.png\">\n *     </dom-module>\n *\n * Then in code in some other location that cannot access the dom-module above\n *\n *     let img = customElements.get('dom-module').import('foo', 'img');\n *\n * @customElement\n * @extends HTMLElement\n * @memberof Polymer\n * @summary Custom element that provides a registry of relocatable DOM content\n *   by `id` that is agnostic to bundling.\n * @unrestricted\n */\n\nvar DomModule = function (_HTMLElement) {\n  _inherits(DomModule, _HTMLElement);\n\n  function DomModule() {\n    _classCallCheck(this, DomModule);\n\n    return _possibleConstructorReturn(this, (DomModule.__proto__ || Object.getPrototypeOf(DomModule)).apply(this, arguments));\n  }\n\n  _createClass(DomModule, [{\n    key: 'attributeChangedCallback',\n\n\n    /**\n     * @param {string} name Name of attribute.\n     * @param {?string} old Old value of attribute.\n     * @param {?string} value Current value of attribute.\n     * @return {void}\n     */\n    value: function attributeChangedCallback(name, old, value) {\n      if (old !== value) {\n        this.register();\n      }\n    }\n\n    /**\n     * The absolute URL of the original location of this `dom-module`.\n     *\n     * This value will differ from this element's `ownerDocument` in the\n     * following ways:\n     * - Takes into account any `assetpath` attribute added during bundling\n     *   to indicate the original location relative to the bundled location\n     * - Uses the HTMLImports polyfill's `importForElement` API to ensure\n     *   the path is relative to the import document's location since\n     *   `ownerDocument` is not currently polyfilled\n     */\n\n  }, {\n    key: 'register',\n\n\n    /**\n     * Registers the dom-module at a given id. This method should only be called\n     * when a dom-module is imperatively created. For\n     * example, `document.createElement('dom-module').register('foo')`.\n     * @param {string=} id The id at which to register the dom-module.\n     * @return {void}\n     */\n    value: function register(id) {\n      id = id || this.id;\n      if (id) {\n        this.id = id;\n        // store id separate from lowercased id so that\n        // in all cases mixedCase id will stored distinctly\n        // and lowercase version is a fallback\n        modules[id] = this;\n        lcModules[id.toLowerCase()] = this;\n        styleOutsideTemplateCheck(this);\n      }\n    }\n  }, {\n    key: 'assetpath',\n    get: function get() {\n      // Don't override existing assetpath.\n      if (!this.__assetpath) {\n        // note: assetpath set via an attribute must be relative to this\n        // element's location; accomodate polyfilled HTMLImports\n        var owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;\n        var url = (0, _resolveUrl.resolveUrl)(this.getAttribute('assetpath') || '', owner.baseURI);\n        this.__assetpath = (0, _resolveUrl.pathFromUrl)(url);\n      }\n      return this.__assetpath;\n    }\n  }], [{\n    key: 'import',\n\n\n    /**\n     * Retrieves the element specified by the css `selector` in the module\n     * registered by `id`. For example, this.import('foo', 'img');\n     * @param {string} id The id of the dom-module in which to search.\n     * @param {string=} selector The css selector by which to find the element.\n     * @return {Element} Returns the element which matches `selector` in the\n     * module registered at the specified `id`.\n     */\n    value: function _import(id, selector) {\n      if (id) {\n        var m = findModule(id);\n        if (m && selector) {\n          return m.querySelector(selector);\n        }\n        return m;\n      }\n      return null;\n    }\n  }, {\n    key: 'observedAttributes',\n    get: function get() {\n      return ['id'];\n    }\n  }]);\n\n  return DomModule;\n}(HTMLElement);\n\nDomModule.prototype['modules'] = modules;\n\ncustomElements.define('dom-module', DomModule);\n\nexports.DomModule = DomModule;\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/elements/dom-module.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/elements/dom-repeat.js":
/*!******************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/elements/dom-repeat.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DomRepeat = undefined;\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _polymerElement = __webpack_require__(/*! ../../polymer-element.js */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n\nvar _templatize = __webpack_require__(/*! ../utils/templatize.js */ \"./node_modules/@polymer/polymer/lib/utils/templatize.js\");\n\nvar _debounce = __webpack_require__(/*! ../utils/debounce.js */ \"./node_modules/@polymer/polymer/lib/utils/debounce.js\");\n\nvar _flush = __webpack_require__(/*! ../utils/flush.js */ \"./node_modules/@polymer/polymer/lib/utils/flush.js\");\n\nvar _mutableData = __webpack_require__(/*! ../mixins/mutable-data.js */ \"./node_modules/@polymer/polymer/lib/mixins/mutable-data.js\");\n\nvar _path = __webpack_require__(/*! ../utils/path.js */ \"./node_modules/@polymer/polymer/lib/utils/path.js\");\n\nvar _async = __webpack_require__(/*! ../utils/async.js */ \"./node_modules/@polymer/polymer/lib/utils/async.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar TemplateInstanceBase = _templatize.TemplateInstanceBase; // eslint-disable-line\n\n/**\n * @constructor\n * @implements {Polymer_OptionalMutableData}\n * @extends {Polymer.Element}\n */\nvar domRepeatBase = (0, _mutableData.OptionalMutableData)(_polymerElement.PolymerElement);\n\n/**\n * The `<dom-repeat>` element will automatically stamp and binds one instance\n * of template content to each object in a user-provided array.\n * `dom-repeat` accepts an `items` property, and one instance of the template\n * is stamped for each item into the DOM at the location of the `dom-repeat`\n * element.  The `item` property will be set on each instance's binding\n * scope, thus templates should bind to sub-properties of `item`.\n *\n * Example:\n *\n * ```html\n * <dom-module id=\"employee-list\">\n *\n *   <template>\n *\n *     <div> Employee list: </div>\n *     <dom-repeat items=\"{{employees}}\">\n *       <template>\n *         <div>First name: <span>{{item.first}}</span></div>\n *         <div>Last name: <span>{{item.last}}</span></div>\n *       </template>\n *     </dom-repeat>\n *\n *   </template>\n *\n * </dom-module>\n * ```\n *\n * With the following custom element definition:\n *\n * ```js\n * class EmployeeList extends Polymer.Element {\n *   static get is() { return 'employee-list'; }\n *   static get properties() {\n *     return {\n *       employees: {\n *         value() {\n *           return [\n *             {first: 'Bob', last: 'Smith'},\n *             {first: 'Sally', last: 'Johnson'},\n *             ...\n *           ];\n *         }\n *       }\n *     };\n *   }\n * }\n * ```\n *\n * Notifications for changes to items sub-properties will be forwarded to template\n * instances, which will update via the normal structured data notification system.\n *\n * Mutations to the `items` array itself should be made using the Array\n * mutation API's on `Polymer.Base` (`push`, `pop`, `splice`, `shift`,\n * `unshift`), and template instances will be kept in sync with the data in the\n * array.\n *\n * Events caught by event handlers within the `dom-repeat` template will be\n * decorated with a `model` property, which represents the binding scope for\n * each template instance.  The model is an instance of Polymer.Base, and should\n * be used to manipulate data on the instance, for example\n * `event.model.set('item.checked', true);`.\n *\n * Alternatively, the model for a template instance for an element stamped by\n * a `dom-repeat` can be obtained using the `modelForElement` API on the\n * `dom-repeat` that stamped it, for example\n * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.\n * This may be useful for manipulating instance data of event targets obtained\n * by event handlers on parents of the `dom-repeat` (event delegation).\n *\n * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a\n * `filter` and/or `sort` property.  This may be a string that names a function on\n * the host, or a function may be assigned to the property directly.  The functions\n * should implemented following the standard `Array` filter/sort API.\n *\n * In order to re-run the filter or sort functions based on changes to sub-fields\n * of `items`, the `observe` property may be set as a space-separated list of\n * `item` sub-fields that should cause a re-filter/sort when modified.  If\n * the filter or sort function depends on properties not contained in `items`,\n * the user should observe changes to those properties and call `render` to update\n * the view based on the dependency change.\n *\n * For example, for an `dom-repeat` with a filter of the following:\n *\n * ```js\n * isEngineer(item) {\n *   return item.type == 'engineer' || item.manager.type == 'engineer';\n * }\n * ```\n *\n * Then the `observe` property should be configured as follows:\n *\n * ```html\n * <dom-repeat items=\"{{employees}}\" filter=\"isEngineer\" observe=\"type manager.type\">\n * ```\n *\n * @customElement\n * @polymer\n * @memberof Polymer\n * @extends {domRepeatBase}\n * @appliesMixin Polymer.OptionalMutableData\n * @summary Custom element for stamping instance of a template bound to\n *   items in an array.\n */\n\nvar DomRepeat = function (_domRepeatBase) {\n  _inherits(DomRepeat, _domRepeatBase);\n\n  _createClass(DomRepeat, null, [{\n    key: 'is',\n\n\n    // Not needed to find template; can be removed once the analyzer\n    // can find the tag name from customElements.define call\n    get: function get() {\n      return 'dom-repeat';\n    }\n  }, {\n    key: 'template',\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: 'properties',\n    get: function get() {\n\n      /**\n       * Fired whenever DOM is added or removed by this template (by\n       * default, rendering occurs lazily).  To force immediate rendering, call\n       * `render`.\n       *\n       * @event dom-change\n       */\n      return {\n\n        /**\n         * An array containing items determining how many instances of the template\n         * to stamp and that that each template instance should bind to.\n         */\n        items: {\n          type: Array\n        },\n\n        /**\n         * The name of the variable to add to the binding scope for the array\n         * element associated with a given template instance.\n         */\n        as: {\n          type: String,\n          value: 'item'\n        },\n\n        /**\n         * The name of the variable to add to the binding scope with the index\n         * of the instance in the sorted and filtered list of rendered items.\n         * Note, for the index in the `this.items` array, use the value of the\n         * `itemsIndexAs` property.\n         */\n        indexAs: {\n          type: String,\n          value: 'index'\n        },\n\n        /**\n         * The name of the variable to add to the binding scope with the index\n         * of the instance in the `this.items` array. Note, for the index of\n         * this instance in the sorted and filtered list of rendered items,\n         * use the value of the `indexAs` property.\n         */\n        itemsIndexAs: {\n          type: String,\n          value: 'itemsIndex'\n        },\n\n        /**\n         * A function that should determine the sort order of the items.  This\n         * property should either be provided as a string, indicating a method\n         * name on the element's host, or else be an actual function.  The\n         * function should match the sort function passed to `Array.sort`.\n         * Using a sort function has no effect on the underlying `items` array.\n         */\n        sort: {\n          type: Function,\n          observer: '__sortChanged'\n        },\n\n        /**\n         * A function that can be used to filter items out of the view.  This\n         * property should either be provided as a string, indicating a method\n         * name on the element's host, or else be an actual function.  The\n         * function should match the sort function passed to `Array.filter`.\n         * Using a filter function has no effect on the underlying `items` array.\n         */\n        filter: {\n          type: Function,\n          observer: '__filterChanged'\n        },\n\n        /**\n         * When using a `filter` or `sort` function, the `observe` property\n         * should be set to a space-separated list of the names of item\n         * sub-fields that should trigger a re-sort or re-filter when changed.\n         * These should generally be fields of `item` that the sort or filter\n         * function depends on.\n         */\n        observe: {\n          type: String,\n          observer: '__observeChanged'\n        },\n\n        /**\n         * When using a `filter` or `sort` function, the `delay` property\n         * determines a debounce time in ms after a change to observed item\n         * properties that must pass before the filter or sort is re-run.\n         * This is useful in rate-limiting shuffling of the view when\n         * item changes may be frequent.\n         */\n        delay: Number,\n\n        /**\n         * Count of currently rendered items after `filter` (if any) has been applied.\n         * If \"chunking mode\" is enabled, `renderedItemCount` is updated each time a\n         * set of template instances is rendered.\n         *\n         */\n        renderedItemCount: {\n          type: Number,\n          notify: true,\n          readOnly: true\n        },\n\n        /**\n         * Defines an initial count of template instances to render after setting\n         * the `items` array, before the next paint, and puts the `dom-repeat`\n         * into \"chunking mode\".  The remaining items will be created and rendered\n         * incrementally at each animation frame therof until all instances have\n         * been rendered.\n         */\n        initialCount: {\n          type: Number,\n          observer: '__initializeChunking'\n        },\n\n        /**\n         * When `initialCount` is used, this property defines a frame rate (in\n         * fps) to target by throttling the number of instances rendered each\n         * frame to not exceed the budget for the target frame rate.  The\n         * framerate is effectively the number of `requestAnimationFrame`s that\n         * it tries to allow to actually fire in a given second. It does this\n         * by measuring the time between `rAF`s and continuously adjusting the\n         * number of items created each `rAF` to maintain the target framerate.\n         * Setting this to a higher number allows lower latency and higher\n         * throughput for event handlers and other tasks, but results in a\n         * longer time for the remaining items to complete rendering.\n         */\n        targetFramerate: {\n          type: Number,\n          value: 20\n        },\n\n        _targetFrameTime: {\n          type: Number,\n          computed: '__computeFrameTime(targetFramerate)'\n        }\n\n      };\n    }\n  }, {\n    key: 'observers',\n    get: function get() {\n      return ['__itemsChanged(items.*)'];\n    }\n  }]);\n\n  function DomRepeat() {\n    _classCallCheck(this, DomRepeat);\n\n    var _this = _possibleConstructorReturn(this, (DomRepeat.__proto__ || Object.getPrototypeOf(DomRepeat)).call(this));\n\n    _this.__instances = [];\n    _this.__limit = Infinity;\n    _this.__pool = [];\n    _this.__renderDebouncer = null;\n    _this.__itemsIdxToInstIdx = {};\n    _this.__chunkCount = null;\n    _this.__lastChunkTime = null;\n    _this.__sortFn = null;\n    _this.__filterFn = null;\n    _this.__observePaths = null;\n    _this.__ctor = null;\n    _this.__isDetached = true;\n    _this.template = null;\n    return _this;\n  }\n\n  /**\n   * @return {void}\n   */\n\n\n  _createClass(DomRepeat, [{\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      _get(DomRepeat.prototype.__proto__ || Object.getPrototypeOf(DomRepeat.prototype), 'disconnectedCallback', this).call(this);\n      this.__isDetached = true;\n      for (var i = 0; i < this.__instances.length; i++) {\n        this.__detachInstance(i);\n      }\n    }\n\n    /**\n     * @return {void}\n     */\n\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      _get(DomRepeat.prototype.__proto__ || Object.getPrototypeOf(DomRepeat.prototype), 'connectedCallback', this).call(this);\n      this.style.display = 'none';\n      // only perform attachment if the element was previously detached.\n      if (this.__isDetached) {\n        this.__isDetached = false;\n        var parent = this.parentNode;\n        for (var i = 0; i < this.__instances.length; i++) {\n          this.__attachInstance(i, parent);\n        }\n      }\n    }\n  }, {\n    key: '__ensureTemplatized',\n    value: function __ensureTemplatized() {\n      var _this2 = this;\n\n      // Templatizing (generating the instance constructor) needs to wait\n      // until ready, since won't have its template content handed back to\n      // it until then\n      if (!this.__ctor) {\n        var template = this.template = /** @type {HTMLTemplateElement} */this.querySelector('template');\n        if (!template) {\n          // // Wait until childList changes and template should be there by then\n          var observer = new MutationObserver(function () {\n            if (_this2.querySelector('template')) {\n              observer.disconnect();\n              _this2.__render();\n            } else {\n              throw new Error('dom-repeat requires a <template> child');\n            }\n          });\n          observer.observe(this, { childList: true });\n          return false;\n        }\n        // Template instance props that should be excluded from forwarding\n        var instanceProps = {};\n        instanceProps[this.as] = true;\n        instanceProps[this.indexAs] = true;\n        instanceProps[this.itemsIndexAs] = true;\n        this.__ctor = (0, _templatize.templatize)(template, this, {\n          mutableData: this.mutableData,\n          parentModel: true,\n          instanceProps: instanceProps,\n          /**\n           * @this {this}\n           * @param {string} prop Property to set\n           * @param {*} value Value to set property to\n           */\n          forwardHostProp: function forwardHostProp(prop, value) {\n            var i$ = this.__instances;\n            for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {\n              inst.forwardHostProp(prop, value);\n            }\n          },\n          /**\n           * @this {this}\n           * @param {Object} inst Instance to notify\n           * @param {string} prop Property to notify\n           * @param {*} value Value to notify\n           */\n          notifyInstanceProp: function notifyInstanceProp(inst, prop, value) {\n            if ((0, _path.matches)(this.as, prop)) {\n              var idx = inst[this.itemsIndexAs];\n              if (prop == this.as) {\n                this.items[idx] = value;\n              }\n              var path = (0, _path.translate)(this.as, 'items.' + idx, prop);\n              this.notifyPath(path, value);\n            }\n          }\n        });\n      }\n      return true;\n    }\n  }, {\n    key: '__getMethodHost',\n    value: function __getMethodHost() {\n      // Technically this should be the owner of the outermost template.\n      // In shadow dom, this is always getRootNode().host, but we can\n      // approximate this via cooperation with our dataHost always setting\n      // `_methodHost` as long as there were bindings (or id's) on this\n      // instance causing it to get a dataHost.\n      return this.__dataHost._methodHost || this.__dataHost;\n    }\n  }, {\n    key: '__functionFromPropertyValue',\n    value: function __functionFromPropertyValue(functionOrMethodName) {\n      if (typeof functionOrMethodName === 'string') {\n        var methodName = functionOrMethodName;\n        var obj = this.__getMethodHost();\n        return function () {\n          return obj[methodName].apply(obj, arguments);\n        };\n      }\n\n      return functionOrMethodName;\n    }\n  }, {\n    key: '__sortChanged',\n    value: function __sortChanged(sort) {\n      this.__sortFn = this.__functionFromPropertyValue(sort);\n      if (this.items) {\n        this.__debounceRender(this.__render);\n      }\n    }\n  }, {\n    key: '__filterChanged',\n    value: function __filterChanged(filter) {\n      this.__filterFn = this.__functionFromPropertyValue(filter);\n      if (this.items) {\n        this.__debounceRender(this.__render);\n      }\n    }\n  }, {\n    key: '__computeFrameTime',\n    value: function __computeFrameTime(rate) {\n      return Math.ceil(1000 / rate);\n    }\n  }, {\n    key: '__initializeChunking',\n    value: function __initializeChunking() {\n      if (this.initialCount) {\n        this.__limit = this.initialCount;\n        this.__chunkCount = this.initialCount;\n        this.__lastChunkTime = performance.now();\n      }\n    }\n  }, {\n    key: '__tryRenderChunk',\n    value: function __tryRenderChunk() {\n      // Debounced so that multiple calls through `_render` between animation\n      // frames only queue one new rAF (e.g. array mutation & chunked render)\n      if (this.items && this.__limit < this.items.length) {\n        this.__debounceRender(this.__requestRenderChunk);\n      }\n    }\n  }, {\n    key: '__requestRenderChunk',\n    value: function __requestRenderChunk() {\n      var _this3 = this;\n\n      requestAnimationFrame(function () {\n        return _this3.__renderChunk();\n      });\n    }\n  }, {\n    key: '__renderChunk',\n    value: function __renderChunk() {\n      // Simple auto chunkSize throttling algorithm based on feedback loop:\n      // measure actual time between frames and scale chunk count by ratio\n      // of target/actual frame time\n      var currChunkTime = performance.now();\n      var ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);\n      this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;\n      this.__limit += this.__chunkCount;\n      this.__lastChunkTime = currChunkTime;\n      this.__debounceRender(this.__render);\n    }\n  }, {\n    key: '__observeChanged',\n    value: function __observeChanged() {\n      this.__observePaths = this.observe && this.observe.replace('.*', '.').split(' ');\n    }\n  }, {\n    key: '__itemsChanged',\n    value: function __itemsChanged(change) {\n      if (this.items && !Array.isArray(this.items)) {\n        console.warn('dom-repeat expected array for `items`, found', this.items);\n      }\n      // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the\n      // path to that instance synchronously (returns false for non-item paths)\n      if (!this.__handleItemPath(change.path, change.value)) {\n        // Otherwise, the array was reset ('items') or spliced ('items.splices'),\n        // so queue a full refresh\n        this.__initializeChunking();\n        this.__debounceRender(this.__render);\n      }\n    }\n  }, {\n    key: '__handleObservedPaths',\n    value: function __handleObservedPaths(path) {\n      // Handle cases where path changes should cause a re-sort/filter\n      if (this.__sortFn || this.__filterFn) {\n        if (!path) {\n          // Always re-render if the item itself changed\n          this.__debounceRender(this.__render, this.delay);\n        } else if (this.__observePaths) {\n          // Otherwise, re-render if the path changed matches an observed path\n          var paths = this.__observePaths;\n          for (var i = 0; i < paths.length; i++) {\n            if (path.indexOf(paths[i]) === 0) {\n              this.__debounceRender(this.__render, this.delay);\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {function(this:DomRepeat)} fn Function to debounce.\n     * @param {number=} delay Delay in ms to debounce by.\n     */\n\n  }, {\n    key: '__debounceRender',\n    value: function __debounceRender(fn) {\n      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      this.__renderDebouncer = _debounce.Debouncer.debounce(this.__renderDebouncer, delay > 0 ? _async.timeOut.after(delay) : _async.microTask, fn.bind(this));\n      (0, _flush.enqueueDebouncer)(this.__renderDebouncer);\n    }\n\n    /**\n     * Forces the element to render its content. Normally rendering is\n     * asynchronous to a provoking change. This is done for efficiency so\n     * that multiple changes trigger only a single render. The render method\n     * should be called if, for example, template rendering is required to\n     * validate application state.\n     * @return {void}\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      // Queue this repeater, then flush all in order\n      this.__debounceRender(this.__render);\n      (0, _flush.flush)();\n    }\n  }, {\n    key: '__render',\n    value: function __render() {\n      if (!this.__ensureTemplatized()) {\n        // No template found yet\n        return;\n      }\n      this.__applyFullRefresh();\n      // Reset the pool\n      // TODO(kschaaf): Reuse pool across turns and nested templates\n      // Now that objects/arrays are re-evaluated when set, we can safely\n      // reuse pooled instances across turns, however we still need to decide\n      // semantics regarding how long to hold, how many to hold, etc.\n      this.__pool.length = 0;\n      // Set rendered item count\n      this._setRenderedItemCount(this.__instances.length);\n      // Notify users\n      this.dispatchEvent(new CustomEvent('dom-change', {\n        bubbles: true,\n        composed: true\n      }));\n      // Check to see if we need to render more items\n      this.__tryRenderChunk();\n    }\n  }, {\n    key: '__applyFullRefresh',\n    value: function __applyFullRefresh() {\n      var _this4 = this;\n\n      var items = this.items || [];\n      var isntIdxToItemsIdx = new Array(items.length);\n      for (var i = 0; i < items.length; i++) {\n        isntIdxToItemsIdx[i] = i;\n      }\n      // Apply user filter\n      if (this.__filterFn) {\n        isntIdxToItemsIdx = isntIdxToItemsIdx.filter(function (i, idx, array) {\n          return _this4.__filterFn(items[i], idx, array);\n        });\n      }\n      // Apply user sort\n      if (this.__sortFn) {\n        isntIdxToItemsIdx.sort(function (a, b) {\n          return _this4.__sortFn(items[a], items[b]);\n        });\n      }\n      // items->inst map kept for item path forwarding\n      var itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};\n      var instIdx = 0;\n      // Generate instances and assign items\n      var limit = Math.min(isntIdxToItemsIdx.length, this.__limit);\n      for (; instIdx < limit; instIdx++) {\n        var inst = this.__instances[instIdx];\n        var itemIdx = isntIdxToItemsIdx[instIdx];\n        var item = items[itemIdx];\n        itemsIdxToInstIdx[itemIdx] = instIdx;\n        if (inst) {\n          inst._setPendingProperty(this.as, item);\n          inst._setPendingProperty(this.indexAs, instIdx);\n          inst._setPendingProperty(this.itemsIndexAs, itemIdx);\n          inst._flushProperties();\n        } else {\n          this.__insertInstance(item, instIdx, itemIdx);\n        }\n      }\n      // Remove any extra instances from previous state\n      for (var _i = this.__instances.length - 1; _i >= instIdx; _i--) {\n        this.__detachAndRemoveInstance(_i);\n      }\n    }\n  }, {\n    key: '__detachInstance',\n    value: function __detachInstance(idx) {\n      var inst = this.__instances[idx];\n      for (var i = 0; i < inst.children.length; i++) {\n        var el = inst.children[i];\n        inst.root.appendChild(el);\n      }\n      return inst;\n    }\n  }, {\n    key: '__attachInstance',\n    value: function __attachInstance(idx, parent) {\n      var inst = this.__instances[idx];\n      parent.insertBefore(inst.root, this);\n    }\n  }, {\n    key: '__detachAndRemoveInstance',\n    value: function __detachAndRemoveInstance(idx) {\n      var inst = this.__detachInstance(idx);\n      if (inst) {\n        this.__pool.push(inst);\n      }\n      this.__instances.splice(idx, 1);\n    }\n  }, {\n    key: '__stampInstance',\n    value: function __stampInstance(item, instIdx, itemIdx) {\n      var model = {};\n      model[this.as] = item;\n      model[this.indexAs] = instIdx;\n      model[this.itemsIndexAs] = itemIdx;\n      return new this.__ctor(model);\n    }\n  }, {\n    key: '__insertInstance',\n    value: function __insertInstance(item, instIdx, itemIdx) {\n      var inst = this.__pool.pop();\n      if (inst) {\n        // TODO(kschaaf): If the pool is shared across turns, hostProps\n        // need to be re-set to reused instances in addition to item\n        inst._setPendingProperty(this.as, item);\n        inst._setPendingProperty(this.indexAs, instIdx);\n        inst._setPendingProperty(this.itemsIndexAs, itemIdx);\n        inst._flushProperties();\n      } else {\n        inst = this.__stampInstance(item, instIdx, itemIdx);\n      }\n      var beforeRow = this.__instances[instIdx + 1];\n      var beforeNode = beforeRow ? beforeRow.children[0] : this;\n      this.parentNode.insertBefore(inst.root, beforeNode);\n      this.__instances[instIdx] = inst;\n      return inst;\n    }\n\n    // Implements extension point from Templatize mixin\n    /**\n     * Shows or hides the template instance top level child elements. For\n     * text nodes, `textContent` is removed while \"hidden\" and replaced when\n     * \"shown.\"\n     * @param {boolean} hidden Set to true to hide the children;\n     * set to false to show them.\n     * @return {void}\n     * @protected\n     */\n\n  }, {\n    key: '_showHideChildren',\n    value: function _showHideChildren(hidden) {\n      for (var i = 0; i < this.__instances.length; i++) {\n        this.__instances[i]._showHideChildren(hidden);\n      }\n    }\n\n    // Called as a side effect of a host items.<key>.<path> path change,\n    // responsible for notifying item.<path> changes to inst for key\n\n  }, {\n    key: '__handleItemPath',\n    value: function __handleItemPath(path, value) {\n      var itemsPath = path.slice(6); // 'items.'.length == 6\n      var dot = itemsPath.indexOf('.');\n      var itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);\n      // If path was index into array...\n      if (itemsIdx == parseInt(itemsIdx, 10)) {\n        var itemSubPath = dot < 0 ? '' : itemsPath.substring(dot + 1);\n        // If the path is observed, it will trigger a full refresh\n        this.__handleObservedPaths(itemSubPath);\n        // Note, even if a rull refresh is triggered, always do the path\n        // notification because unless mutableData is used for dom-repeat\n        // and all elements in the instance subtree, a full refresh may\n        // not trigger the proper update.\n        var instIdx = this.__itemsIdxToInstIdx[itemsIdx];\n        var inst = this.__instances[instIdx];\n        if (inst) {\n          var itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');\n          // This is effectively `notifyPath`, but avoids some of the overhead\n          // of the public API\n          inst._setPendingPropertyOrPath(itemPath, value, false, true);\n          inst._flushProperties();\n        }\n        return true;\n      }\n    }\n\n    /**\n     * Returns the item associated with a given element stamped by\n     * this `dom-repeat`.\n     *\n     * Note, to modify sub-properties of the item,\n     * `modelForElement(el).set('item.<sub-prop>', value)`\n     * should be used.\n     *\n     * @param {!HTMLElement} el Element for which to return the item.\n     * @return {*} Item associated with the element.\n     */\n\n  }, {\n    key: 'itemForElement',\n    value: function itemForElement(el) {\n      var instance = this.modelForElement(el);\n      return instance && instance[this.as];\n    }\n\n    /**\n     * Returns the inst index for a given element stamped by this `dom-repeat`.\n     * If `sort` is provided, the index will reflect the sorted order (rather\n     * than the original array order).\n     *\n     * @param {!HTMLElement} el Element for which to return the index.\n     * @return {?number} Row index associated with the element (note this may\n     *   not correspond to the array index if a user `sort` is applied).\n     */\n\n  }, {\n    key: 'indexForElement',\n    value: function indexForElement(el) {\n      var instance = this.modelForElement(el);\n      return instance && instance[this.indexAs];\n    }\n\n    /**\n     * Returns the template \"model\" associated with a given element, which\n     * serves as the binding scope for the template instance the element is\n     * contained in. A template model is an instance of `Polymer.Base`, and\n     * should be used to manipulate data associated with this template instance.\n     *\n     * Example:\n     *\n     *   let model = modelForElement(el);\n     *   if (model.index < 10) {\n     *     model.set('item.checked', true);\n     *   }\n     *\n     * @param {!HTMLElement} el Element for which to return a template model.\n     * @return {TemplateInstanceBase} Model representing the binding scope for\n     *   the element.\n     */\n\n  }, {\n    key: 'modelForElement',\n    value: function modelForElement(el) {\n      return (0, _templatize.modelForElement)(this.template, el);\n    }\n  }]);\n\n  return DomRepeat;\n}(domRepeatBase);\n\ncustomElements.define(DomRepeat.is, DomRepeat);\n\nexports.DomRepeat = DomRepeat;\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/elements/dom-repeat.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/element-mixin.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/element-mixin.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateStyles = exports.registrations = exports.instanceCount = exports.ElementMixin = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nexports._regLog = _regLog;\nexports.register = register;\nexports.dumpRegistrations = dumpRegistrations;\n\n__webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n\nvar _settings = __webpack_require__(/*! ../utils/settings.js */ \"./node_modules/@polymer/polymer/lib/utils/settings.js\");\n\nvar _mixin = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@polymer/polymer/lib/utils/mixin.js\");\n\nvar _styleGather = __webpack_require__(/*! ../utils/style-gather.js */ \"./node_modules/@polymer/polymer/lib/utils/style-gather.js\");\n\nvar _resolveUrl = __webpack_require__(/*! ../utils/resolve-url.js */ \"./node_modules/@polymer/polymer/lib/utils/resolve-url.js\");\n\nvar _domModule = __webpack_require__(/*! ../elements/dom-module.js */ \"./node_modules/@polymer/polymer/lib/elements/dom-module.js\");\n\nvar _propertyEffects = __webpack_require__(/*! ./property-effects.js */ \"./node_modules/@polymer/polymer/lib/mixins/property-effects.js\");\n\nvar _propertiesMixin = __webpack_require__(/*! ./properties-mixin.js */ \"./node_modules/@polymer/polymer/lib/mixins/properties-mixin.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ElementMixin = exports.ElementMixin = (0, _mixin.dedupingMixin)(function (base) {\n\n  /**\n   * @constructor\n   * @extends {base}\n   * @implements {Polymer_PropertyEffects}\n   * @implements {Polymer_PropertiesMixin}\n   */\n  var polymerElementBase = (0, _propertiesMixin.PropertiesMixin)((0, _propertyEffects.PropertyEffects)(base));\n\n  /**\n   * Returns a list of properties with default values.\n   * This list is created as an optimization since it is a subset of\n   * the list returned from `_properties`.\n   * This list is used in `_initializeProperties` to set property defaults.\n   *\n   * @param {PolymerElementConstructor} constructor Element class\n   * @return {PolymerElementProperties} Flattened properties for this class\n   *   that have default values\n   * @private\n   */\n  function propertyDefaults(constructor) {\n    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__propertyDefaults', constructor))) {\n      constructor.__propertyDefaults = null;\n      var props = constructor._properties;\n      for (var p in props) {\n        var info = props[p];\n        if ('value' in info) {\n          constructor.__propertyDefaults = constructor.__propertyDefaults || {};\n          constructor.__propertyDefaults[p] = info;\n        }\n      }\n    }\n    return constructor.__propertyDefaults;\n  }\n\n  /**\n   * Returns a memoized version of the the `observers` array.\n   * @param {PolymerElementConstructor} constructor Element class\n   * @return {Array} Array containing own observers for the given class\n   * @protected\n   */\n  function ownObservers(constructor) {\n    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', constructor))) {\n      constructor.__ownObservers = constructor.hasOwnProperty(JSCompiler_renameProperty('observers', constructor)) ?\n      /** @type {PolymerElementConstructor} */constructor.observers : null;\n    }\n    return constructor.__ownObservers;\n  }\n\n  /**\n   * Creates effects for a property.\n   *\n   * Note, once a property has been set to\n   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`\n   * these values may not be changed. For example, a subclass cannot\n   * alter these settings. However, additional `observers` may be added\n   * by subclasses.\n   *\n   * The info object should may contain property metadata as follows:\n   *\n   * * `type`: {function} type to which an attribute matching the property\n   * is deserialized. Note the property is camel-cased from a dash-cased\n   * attribute. For example, 'foo-bar' attribute is deserialized to a\n   * property named 'fooBar'.\n   *\n   * * `readOnly`: {boolean} creates a readOnly property and\n   * makes a private setter for the private of the form '_setFoo' for a\n   * property 'foo',\n   *\n   * * `computed`: {string} creates a computed property. A computed property\n   * also automatically is set to `readOnly: true`. The value is calculated\n   * by running a method and arguments parsed from the given string. For\n   * example 'compute(foo)' will compute a given property when the\n   * 'foo' property changes by executing the 'compute' method. This method\n   * must return the computed value.\n   *\n   * * `reflectToAttribute`: {boolean} If true, the property value is reflected\n   * to an attribute of the same name. Note, the attribute is dash-cased\n   * so a property named 'fooBar' is reflected as 'foo-bar'.\n   *\n   * * `notify`: {boolean} sends a non-bubbling notification event when\n   * the property changes. For example, a property named 'foo' sends an\n   * event named 'foo-changed' with `event.detail` set to the value of\n   * the property.\n   *\n   * * observer: {string} name of a method that runs when the property\n   * changes. The arguments of the method are (value, previousValue).\n   *\n   * Note: Users may want control over modifying property\n   * effects via subclassing. For example, a user might want to make a\n   * reflectToAttribute property not do so in a subclass. We've chosen to\n   * disable this because it leads to additional complication.\n   * For example, a readOnly effect generates a special setter. If a subclass\n   * disables the effect, the setter would fail unexpectedly.\n   * Based on feedback, we may want to try to make effects more malleable\n   * and/or provide an advanced api for manipulating them.\n   * Also consider adding warnings when an effect cannot be changed.\n   *\n   * @param {!PolymerElement} proto Element class prototype to add accessors\n   *   and effects to\n   * @param {string} name Name of the property.\n   * @param {Object} info Info object from which to create property effects.\n   * Supported keys:\n   * @param {Object} allProps Flattened map of all properties defined in this\n   *   element (including inherited properties)\n   * @return {void}\n   * @private\n   */\n  function createPropertyFromConfig(proto, name, info, allProps) {\n    // computed forces readOnly...\n    if (info.computed) {\n      info.readOnly = true;\n    }\n    // Note, since all computed properties are readOnly, this prevents\n    // adding additional computed property effects (which leads to a confusing\n    // setup where multiple triggers for setting a property)\n    // While we do have `hasComputedEffect` this is set on the property's\n    // dependencies rather than itself.\n    if (info.computed && !proto._hasReadOnlyEffect(name)) {\n      proto._createComputedProperty(name, info.computed, allProps);\n    }\n    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {\n      proto._createReadOnlyProperty(name, !info.computed);\n    }\n    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {\n      proto._createReflectedProperty(name);\n    }\n    if (info.notify && !proto._hasNotifyEffect(name)) {\n      proto._createNotifyingProperty(name);\n    }\n    // always add observer\n    if (info.observer) {\n      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);\n    }\n    // always create the mapping from attribute back to property for deserialization.\n    proto._addPropertyToAttributeMap(name);\n  }\n\n  /**\n   * Process all style elements in the element template. Styles with the\n   * `include` attribute are processed such that any styles in\n   * the associated \"style modules\" are included in the element template.\n   * @param {PolymerElementConstructor} klass Element class\n   * @param {!HTMLTemplateElement} template Template to process\n   * @param {string} is Name of element\n   * @param {string} baseURI Base URI for element\n   * @private\n   */\n  function processElementStyles(klass, template, is, baseURI) {\n    var templateStyles = template.content.querySelectorAll('style');\n    var stylesWithImports = (0, _styleGather.stylesFromTemplate)(template);\n    // insert styles from <link rel=\"import\" type=\"css\"> at the top of the template\n    var linkedStyles = (0, _styleGather.stylesFromModuleImports)(is);\n    var firstTemplateChild = template.content.firstElementChild;\n    for (var idx = 0; idx < linkedStyles.length; idx++) {\n      var s = linkedStyles[idx];\n      s.textContent = klass._processStyleText(s.textContent, baseURI);\n      template.content.insertBefore(s, firstTemplateChild);\n    }\n    // keep track of the last \"concrete\" style in the template we have encountered\n    var templateStyleIndex = 0;\n    // ensure all gathered styles are actually in this template.\n    for (var i = 0; i < stylesWithImports.length; i++) {\n      var _s = stylesWithImports[i];\n      var templateStyle = templateStyles[templateStyleIndex];\n      // if the style is not in this template, it's been \"included\" and\n      // we put a clone of it in the template before the style that included it\n      if (templateStyle !== _s) {\n        _s = _s.cloneNode(true);\n        templateStyle.parentNode.insertBefore(_s, templateStyle);\n      } else {\n        templateStyleIndex++;\n      }\n      _s.textContent = klass._processStyleText(_s.textContent, baseURI);\n    }\n    if (window.ShadyCSS) {\n      window.ShadyCSS.prepareTemplate(template, is);\n    }\n  }\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @unrestricted\n   * @implements {Polymer_ElementMixin}\n   */\n\n  var PolymerElement = function (_polymerElementBase) {\n    _inherits(PolymerElement, _polymerElementBase);\n\n    _createClass(PolymerElement, null, [{\n      key: '_finalizeClass',\n\n\n      /**\n       * Override of PropertiesMixin _finalizeClass to create observers and\n       * find the template.\n       * @return {void}\n       * @protected\n       * @override\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n      value: function _finalizeClass() {\n        _get(PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement), '_finalizeClass', this).call(this);\n        if (this.hasOwnProperty(JSCompiler_renameProperty('is', this)) && this.is) {\n          register(this.prototype);\n        }\n        var observers = ownObservers(this);\n        if (observers) {\n          this.createObservers(observers, this._properties);\n        }\n        // note: create \"working\" template that is finalized at instance time\n        var template = /** @type {PolymerElementConstructor} */this.template;\n        if (template) {\n          if (typeof template === 'string') {\n            var t = document.createElement('template');\n            t.innerHTML = template;\n            template = t;\n          } else {\n            template = template.cloneNode(true);\n          }\n        }\n\n        this.prototype._template = template;\n      }\n\n      /**\n       * Override of PropertiesChanged createProperties to create accessors\n       * and property effects for all of the properties.\n       * @return {void}\n       * @protected\n       * @override\n       */\n\n    }, {\n      key: 'createProperties',\n      value: function createProperties(props) {\n        for (var p in props) {\n          createPropertyFromConfig(this.prototype, p, props[p], props);\n        }\n      }\n\n      /**\n       * Creates observers for the given `observers` array.\n       * Leverages `PropertyEffects` to create observers.\n       * @param {Object} observers Array of observer descriptors for\n       *   this class\n       * @param {Object} dynamicFns Object containing keys for any properties\n       *   that are functions and should trigger the effect when the function\n       *   reference is changed\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: 'createObservers',\n      value: function createObservers(observers, dynamicFns) {\n        var proto = this.prototype;\n        for (var i = 0; i < observers.length; i++) {\n          proto._createMethodObserver(observers[i], dynamicFns);\n        }\n      }\n\n      /**\n       * Returns the template that will be stamped into this element's shadow root.\n       *\n       * If a `static get is()` getter is defined, the default implementation\n       * will return the first `<template>` in a `dom-module` whose `id`\n       * matches this element's `is`.\n       *\n       * Users may override this getter to return an arbitrary template\n       * (in which case the `is` getter is unnecessary). The template returned\n       * may be either an `HTMLTemplateElement` or a string that will be\n       * automatically parsed into a template.\n       *\n       * Note that when subclassing, if the super class overrode the default\n       * implementation and the subclass would like to provide an alternate\n       * template via a `dom-module`, it should override this getter and\n       * return `Polymer.DomModule.import(this.is, 'template')`.\n       *\n       * If a subclass would like to modify the super class template, it should\n       * clone it rather than modify it in place.  If the getter does expensive\n       * work such as cloning/modifying a template, it should memoize the\n       * template for maximum performance:\n       *\n       *   let memoizedTemplate;\n       *   class MySubClass extends MySuperClass {\n       *     static get template() {\n       *       if (!memoizedTemplate) {\n       *         memoizedTemplate = super.template.cloneNode(true);\n       *         let subContent = document.createElement('div');\n       *         subContent.textContent = 'This came from MySubClass';\n       *         memoizedTemplate.content.appendChild(subContent);\n       *       }\n       *       return memoizedTemplate;\n       *     }\n       *   }\n       *\n       * @return {HTMLTemplateElement|string} Template to be stamped\n       */\n\n    }, {\n      key: 'template',\n      get: function get() {\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {\n          this._template = _domModule.DomModule && _domModule.DomModule.import(\n          /** @type {PolymerElementConstructor}*/this.is, 'template') ||\n          // note: implemented so a subclass can retrieve the super\n          // template; call the super impl this way so that `this` points\n          // to the superclass.\n          Object.getPrototypeOf( /** @type {PolymerElementConstructor}*/this.prototype).constructor.template;\n        }\n        return this._template;\n      }\n\n      /**\n       * Path matching the url from which the element was imported.\n       * This path is used to resolve url's in template style cssText.\n       * The `importPath` property is also set on element instances and can be\n       * used to create bindings relative to the import path.\n       * Defaults to the path matching the url containing a `dom-module` element\n       * matching this element's static `is` property.\n       * Note, this path should contain a trailing `/`.\n       *\n       * @return {string} The import path for this element class\n       */\n\n    }, {\n      key: 'importPath',\n      get: function get() {\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {\n          var module = _domModule.DomModule && _domModule.DomModule.import( /** @type {PolymerElementConstructor} */this.is);\n          this._importPath = module ? module.assetpath : '' || Object.getPrototypeOf( /** @type {PolymerElementConstructor}*/this.prototype).constructor.importPath;\n        }\n        return this._importPath;\n      }\n    }]);\n\n    function PolymerElement() {\n      _classCallCheck(this, PolymerElement);\n\n      /** @type {HTMLTemplateElement} */\n      var _this = _possibleConstructorReturn(this, (PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement)).call(this));\n\n      _this._template;\n      /** @type {string} */\n      _this._importPath;\n      /** @type {string} */\n      _this.rootPath;\n      /** @type {string} */\n      _this.importPath;\n      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */\n      _this.root;\n      /** @type {!Object<string, !Element>} */\n      _this.$;\n      return _this;\n    }\n\n    /**\n     * Overrides the default `Polymer.PropertyAccessors` to ensure class\n     * metaprogramming related to property accessors and effects has\n     * completed (calls `finalize`).\n     *\n     * It also initializes any property defaults provided via `value` in\n     * `properties` metadata.\n     *\n     * @return {void}\n     * @override\n     * @suppress {invalidCasts}\n     */\n\n\n    _createClass(PolymerElement, [{\n      key: '_initializeProperties',\n      value: function _initializeProperties() {\n        exports.instanceCount = instanceCount += 1;\n        this.constructor.finalize();\n        var importPath = this.constructor.importPath;\n        // note: finalize template when we have access to `localName` to\n        // avoid dependence on `is` for polyfilling styling.\n        this.constructor._finalizeTemplate( /** @type {!HTMLElement} */this.localName);\n        _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_initializeProperties', this).call(this);\n        // set path defaults\n        this.rootPath = _settings.rootPath;\n        this.importPath = importPath;\n        // apply property defaults...\n        var p$ = propertyDefaults(this.constructor);\n        if (!p$) {\n          return;\n        }\n        for (var p in p$) {\n          var info = p$[p];\n          // Don't set default value if there is already an own property, which\n          // happens when a `properties` property with default but no effects had\n          // a property set (e.g. bound) by its host before upgrade\n          if (!this.hasOwnProperty(p)) {\n            var value = typeof info.value == 'function' ? info.value.call(this) : info.value;\n            // Set via `_setProperty` if there is an accessor, to enable\n            // initializing readOnly property defaults\n            if (this._hasAccessor(p)) {\n              this._setPendingProperty(p, value, true);\n            } else {\n              this[p] = value;\n            }\n          }\n        }\n      }\n\n      /**\n       * Gather style text for a style element in the template.\n       *\n       * @param {string} cssText Text containing styling to process\n       * @param {string} baseURI Base URI to rebase CSS paths against\n       * @return {string} The processed CSS text\n       * @protected\n       */\n\n    }, {\n      key: 'connectedCallback',\n\n\n      /**\n       * Provides a default implementation of the standard Custom Elements\n       * `connectedCallback`.\n       *\n       * The default implementation enables the property effects system and\n       * flushes any pending properties, and updates shimmed CSS properties\n       * when using the ShadyCSS scoping/custom properties polyfill.\n       *\n       * @suppress {missingProperties, invalidCasts} Super may or may not implement the callback\n       * @return {void}\n       */\n      value: function connectedCallback() {\n        if (window.ShadyCSS && this._template) {\n          window.ShadyCSS.styleElement( /** @type {!HTMLElement} */this);\n        }\n        _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), 'connectedCallback', this).call(this);\n      }\n\n      /**\n       * Stamps the element template.\n       *\n       * @return {void}\n       * @override\n       */\n\n    }, {\n      key: 'ready',\n      value: function ready() {\n        if (this._template) {\n          this.root = this._stampTemplate(this._template);\n          this.$ = this.root.$;\n        }\n        _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), 'ready', this).call(this);\n      }\n\n      /**\n       * Implements `PropertyEffects`'s `_readyClients` call. Attaches\n       * element dom by calling `_attachDom` with the dom stamped from the\n       * element's template via `_stampTemplate`. Note that this allows\n       * client dom to be attached to the element prior to any observers\n       * running.\n       *\n       * @return {void}\n       * @override\n       */\n\n    }, {\n      key: '_readyClients',\n      value: function _readyClients() {\n        if (this._template) {\n          this.root = this._attachDom( /** @type {StampedTemplate} */this.root);\n        }\n        // The super._readyClients here sets the clients initialized flag.\n        // We must wait to do this until after client dom is created/attached\n        // so that this flag can be checked to prevent notifications fired\n        // during this process from being handled before clients are ready.\n        _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_readyClients', this).call(this);\n      }\n\n      /**\n       * Attaches an element's stamped dom to itself. By default,\n       * this method creates a `shadowRoot` and adds the dom to it.\n       * However, this method may be overridden to allow an element\n       * to put its dom in another location.\n       *\n       * @throws {Error}\n       * @suppress {missingReturn}\n       * @param {StampedTemplate} dom to attach to the element.\n       * @return {ShadowRoot} node to which the dom has been attached.\n       */\n\n    }, {\n      key: '_attachDom',\n      value: function _attachDom(dom) {\n        if (this.attachShadow) {\n          if (dom) {\n            if (!this.shadowRoot) {\n              this.attachShadow({ mode: 'open' });\n            }\n            this.shadowRoot.appendChild(dom);\n            return this.shadowRoot;\n          }\n          return null;\n        } else {\n          throw new Error('ShadowDOM not available. ' +\n          // TODO(sorvell): move to compile-time conditional when supported\n          'Polymer.Element can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\\` before \\`ready\\`.');\n        }\n      }\n\n      /**\n       * When using the ShadyCSS scoping and custom property shim, causes all\n       * shimmed styles in this element (and its subtree) to be updated\n       * based on current custom property values.\n       *\n       * The optional parameter overrides inline custom property styles with an\n       * object of properties where the keys are CSS properties, and the values\n       * are strings.\n       *\n       * Example: `this.updateStyles({'--color': 'blue'})`\n       *\n       * These properties are retained unless a value of `null` is set.\n       *\n       * Note: This function does not support updating CSS mixins.\n       * You can not dynamically change the value of an `@apply`.\n       *\n       * @param {Object=} properties Bag of custom property key/values to\n       *   apply to this element.\n       * @return {void}\n       * @suppress {invalidCasts}\n       */\n\n    }, {\n      key: 'updateStyles',\n      value: function updateStyles(properties) {\n        if (window.ShadyCSS) {\n          window.ShadyCSS.styleSubtree( /** @type {!HTMLElement} */this, properties);\n        }\n      }\n\n      /**\n       * Rewrites a given URL relative to a base URL. The base URL defaults to\n       * the original location of the document containing the `dom-module` for\n       * this element. This method will return the same URL before and after\n       * bundling.\n       *\n       * Note that this function performs no resolution for URLs that start\n       * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose\n       * URL resolution, use `window.URL`.\n       *\n       * @param {string} url URL to resolve.\n       * @param {string=} base Optional base URL to resolve against, defaults\n       * to the element's `importPath`\n       * @return {string} Rewritten URL relative to base\n       */\n\n    }, {\n      key: 'resolveUrl',\n      value: function resolveUrl(url, base) {\n        if (!base && this.importPath) {\n          base = (0, _resolveUrl.resolveUrl)(this.importPath);\n        }\n        return (0, _resolveUrl.resolveUrl)(url, base);\n      }\n\n      /**\n       * Overrides `PropertyAccessors` to add map of dynamic functions on\n       * template info, for consumption by `PropertyEffects` template binding\n       * code. This map determines which method templates should have accessors\n       * created for them.\n       *\n       * @override\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n\n    }], [{\n      key: '_processStyleText',\n      value: function _processStyleText(cssText, baseURI) {\n        return (0, _resolveUrl.resolveCss)(cssText, baseURI);\n      }\n\n      /**\n      * Configures an element `proto` to function with a given `template`.\n      * The element name `is` and extends `ext` must be specified for ShadyCSS\n      * style scoping.\n      *\n      * @param {string} is Tag name (or type extension name) for this element\n      * @return {void}\n      * @protected\n      */\n\n    }, {\n      key: '_finalizeTemplate',\n      value: function _finalizeTemplate(is) {\n        /** @const {HTMLTemplateElement} */\n        var template = this.prototype._template;\n        if (template && !template.__polymerFinalized) {\n          template.__polymerFinalized = true;\n          var importPath = this.importPath;\n          var baseURI = importPath ? (0, _resolveUrl.resolveUrl)(importPath) : '';\n          // e.g. support `include=\"module-name\"`, and ShadyCSS\n          processElementStyles(this, template, is, baseURI);\n          this.prototype._bindTemplate(template);\n        }\n      }\n    }, {\n      key: '_parseTemplateContent',\n      value: function _parseTemplateContent(template, templateInfo, nodeInfo) {\n        templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties;\n        return _get(PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement), '_parseTemplateContent', this).call(this, template, templateInfo, nodeInfo);\n      }\n    }]);\n\n    return PolymerElement;\n  }(polymerElementBase);\n\n  return PolymerElement;\n});\n\nvar instanceCount = exports.instanceCount = 0;\nvar registrations = exports.registrations = [];\n\nfunction _regLog(prototype) {\n  console.log('[' + prototype.is + ']: registered');\n}\n\nfunction register(prototype) {\n  registrations.push(prototype);\n  undefined && _regLog(prototype);\n}\n\nfunction dumpRegistrations() {\n  registrations.forEach(_regLog);\n}\n\nvar updateStyles = exports.updateStyles = function updateStyles(props) {\n  if (window.ShadyCSS) {\n    window.ShadyCSS.styleDocument(props);\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/mixins/element-mixin.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/mutable-data.js":
/*!******************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/mutable-data.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OptionalMutableData = exports.MutableData = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _mixin = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@polymer/polymer/lib/utils/mixin.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Common implementation for mixin & behavior\nfunction mutablePropertyChange(inst, property, value, old, mutableData) {\n  var isObject = void 0;\n  if (mutableData) {\n    isObject = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null;\n    // Pull `old` for Objects from temp cache, but treat `null` as a primitive\n    if (isObject) {\n      old = inst.__dataTemp[property];\n    }\n  }\n  // Strict equality check, but return false for NaN===NaN\n  var shouldChange = old !== value && (old === old || value === value);\n  // Objects are stored in temporary cache (cleared at end of\n  // turn), which is used for dirty-checking\n  if (isObject && shouldChange) {\n    inst.__dataTemp[property] = value;\n  }\n  return shouldChange;\n}\n\nvar MutableData = exports.MutableData = (0, _mixin.dedupingMixin)(function (superClass) {\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_MutableData}\n   */\n  var MutableData = function (_superClass) {\n    _inherits(MutableData, _superClass);\n\n    function MutableData() {\n      _classCallCheck(this, MutableData);\n\n      return _possibleConstructorReturn(this, (MutableData.__proto__ || Object.getPrototypeOf(MutableData)).apply(this, arguments));\n    }\n\n    _createClass(MutableData, [{\n      key: '_shouldPropertyChange',\n\n      /**\n       * Overrides `Polymer.PropertyEffects` to provide option for skipping\n       * strict equality checking for Objects and Arrays.\n       *\n       * This method pulls the value to dirty check against from the `__dataTemp`\n       * cache (rather than the normal `__data` cache) for Objects.  Since the temp\n       * cache is cleared at the end of a turn, this implementation allows\n       * side-effects of deep object changes to be processed by re-setting the\n       * same object (using the temp cache as an in-turn backstop to prevent\n       * cycles due to 2-way notification).\n       *\n       * @param {string} property Property name\n       * @param {*} value New property value\n       * @param {*} old Previous property value\n       * @return {boolean} Whether the property should be considered a change\n       * @protected\n       */\n      value: function _shouldPropertyChange(property, value, old) {\n        return mutablePropertyChange(this, property, value, old, true);\n      }\n    }]);\n\n    return MutableData;\n  }(superClass);\n\n  return MutableData;\n});\n\nvar OptionalMutableData = exports.OptionalMutableData = (0, _mixin.dedupingMixin)(function (superClass) {\n\n  /**\n   * @mixinClass\n   * @polymer\n   * @implements {Polymer_OptionalMutableData}\n   */\n  var OptionalMutableData = function (_superClass2) {\n    _inherits(OptionalMutableData, _superClass2);\n\n    function OptionalMutableData() {\n      _classCallCheck(this, OptionalMutableData);\n\n      return _possibleConstructorReturn(this, (OptionalMutableData.__proto__ || Object.getPrototypeOf(OptionalMutableData)).apply(this, arguments));\n    }\n\n    _createClass(OptionalMutableData, [{\n      key: '_shouldPropertyChange',\n\n\n      /**\n       * Overrides `Polymer.PropertyEffects` to provide option for skipping\n       * strict equality checking for Objects and Arrays.\n       *\n       * When `this.mutableData` is true on this instance, this method\n       * pulls the value to dirty check against from the `__dataTemp` cache\n       * (rather than the normal `__data` cache) for Objects.  Since the temp\n       * cache is cleared at the end of a turn, this implementation allows\n       * side-effects of deep object changes to be processed by re-setting the\n       * same object (using the temp cache as an in-turn backstop to prevent\n       * cycles due to 2-way notification).\n       *\n       * @param {string} property Property name\n       * @param {*} value New property value\n       * @param {*} old Previous property value\n       * @return {boolean} Whether the property should be considered a change\n       * @protected\n       */\n      value: function _shouldPropertyChange(property, value, old) {\n        return mutablePropertyChange(this, property, value, old, this.mutableData);\n      }\n    }], [{\n      key: 'properties',\n      get: function get() {\n        return {\n          /**\n           * Instance-level flag for configuring the dirty-checking strategy\n           * for this element.  When true, Objects and Arrays will skip dirty\n           * checking, otherwise strict equality checking will be used.\n           */\n          mutableData: Boolean\n        };\n      }\n    }]);\n\n    return OptionalMutableData;\n  }(superClass);\n\n  return OptionalMutableData;\n});\n\n// Export for use by legacy behavior\nMutableData._mutablePropertyChange = mutablePropertyChange;\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/mixins/mutable-data.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/properties-changed.js":
/*!************************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/properties-changed.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PropertiesChanged = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n\nvar _mixin = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@polymer/polymer/lib/utils/mixin.js\");\n\nvar _async = __webpack_require__(/*! ../utils/async.js */ \"./node_modules/@polymer/polymer/lib/utils/async.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/** @const {!AsyncInterface} */\nvar microtask = _async.microTask;\n\nvar PropertiesChanged = exports.PropertiesChanged = (0, _mixin.dedupingMixin)(function (superClass) {\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @extends {superClass}\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   */\n  var PropertiesChanged = function (_superClass) {\n    _inherits(PropertiesChanged, _superClass);\n\n    _createClass(PropertiesChanged, [{\n      key: '_createPropertyAccessor',\n      //eslint-disable-line no-unused-vars\n\n      /**\n       * Creates a setter/getter pair for the named property with its own\n       * local storage.  The getter returns the value in the local storage,\n       * and the setter calls `_setProperty`, which updates the local storage\n       * for the property and enqueues a `_propertiesChanged` callback.\n       *\n       * This method may be called on a prototype or an instance.  Calling\n       * this method may overwrite a property value that already exists on\n       * the prototype/instance by creating the accessor.\n       *\n       * @param {string} property Name of the property\n       * @param {boolean=} readOnly When true, no setter is created; the\n       *   protected `_setProperty` function must be used to set the property\n       * @return {void}\n       * @protected\n       */\n      value: function _createPropertyAccessor(property, readOnly) {\n        this._addPropertyToAttributeMap(property);\n        if (!this.hasOwnProperty('__dataHasAccessor')) {\n          this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);\n        }\n        if (!this.__dataHasAccessor[property]) {\n          this.__dataHasAccessor[property] = true;\n          this._definePropertyAccessor(property, readOnly);\n        }\n      }\n\n      /**\n       * Adds the given `property` to a map matching attribute names\n       * to property names, using `attributeNameForProperty`. This map is\n       * used when deserializing attribute values to properties.\n       *\n       * @param {string} property Name of the property\n       */\n\n    }, {\n      key: '_addPropertyToAttributeMap',\n      value: function _addPropertyToAttributeMap(property) {\n        if (!this.hasOwnProperty('__dataAttributes')) {\n          this.__dataAttributes = Object.assign({}, this.__dataAttributes);\n        }\n        if (!this.__dataAttributes[property]) {\n          var attr = this.constructor.attributeNameForProperty(property);\n          this.__dataAttributes[attr] = property;\n        }\n      }\n\n      /**\n       * Defines a property accessor for the given property.\n       * @param {string} property Name of the property\n       * @param {boolean=} readOnly When true, no setter is created\n       * @return {void}\n       */\n\n    }, {\n      key: '_definePropertyAccessor',\n      value: function _definePropertyAccessor(property, readOnly) {\n        Object.defineProperty(this, property, {\n          /* eslint-disable valid-jsdoc */\n          /** @this {PropertiesChanged} */\n          get: function get() {\n            return this._getProperty(property);\n          },\n\n          /** @this {PropertiesChanged} */\n          set: readOnly ? function () {} : function (value) {\n            this._setProperty(property, value);\n          }\n          /* eslint-enable */\n        });\n      }\n    }], [{\n      key: 'createProperties',\n\n\n      /**\n       * Creates property accessors for the given property names.\n       * @param {!Object} props Object whose keys are names of accessors.\n       * @return {void}\n       * @protected\n       */\n      value: function createProperties(props) {\n        var proto = this.prototype;\n        for (var prop in props) {\n          // don't stomp an existing accessor\n          if (!(prop in proto)) {\n            proto._createPropertyAccessor(prop);\n          }\n        }\n      }\n\n      /**\n       * Returns an attribute name that corresponds to the given property.\n       * The attribute name is the lowercased property name. Override to\n       * customize this mapping.\n       * @param {string} property Property to convert\n       * @return {string} Attribute name corresponding to the given property.\n       *\n       * @protected\n       */\n\n    }, {\n      key: 'attributeNameForProperty',\n      value: function attributeNameForProperty(property) {\n        return property.toLowerCase();\n      }\n\n      /**\n       * Override point to provide a type to which to deserialize a value to\n       * a given property.\n       * @param {string} name Name of property\n       *\n       * @protected\n       */\n\n    }, {\n      key: 'typeForProperty',\n      value: function typeForProperty(name) {}\n    }]);\n\n    function PropertiesChanged() {\n      _classCallCheck(this, PropertiesChanged);\n\n      var _this = _possibleConstructorReturn(this, (PropertiesChanged.__proto__ || Object.getPrototypeOf(PropertiesChanged)).call(this));\n\n      _this.__dataEnabled = false;\n      _this.__dataReady = false;\n      _this.__dataInvalid = false;\n      _this.__data = {};\n      _this.__dataPending = null;\n      _this.__dataOld = null;\n      _this.__dataInstanceProps = null;\n      _this.__serializing = false;\n      _this._initializeProperties();\n      return _this;\n    }\n\n    /**\n     * Lifecycle callback called when properties are enabled via\n     * `_enableProperties`.\n     *\n     * Users may override this function to implement behavior that is\n     * dependent on the element having its property data initialized, e.g.\n     * from defaults (initialized from `constructor`, `_initializeProperties`),\n     * `attributeChangedCallback`, or values propagated from host e.g. via\n     * bindings.  `super.ready()` must be called to ensure the data system\n     * becomes enabled.\n     *\n     * @return {void}\n     * @public\n     */\n\n\n    _createClass(PropertiesChanged, [{\n      key: 'ready',\n      value: function ready() {\n        this.__dataReady = true;\n        this._flushProperties();\n      }\n\n      /**\n       * Initializes the local storage for property accessors.\n       *\n       * Provided as an override point for performing any setup work prior\n       * to initializing the property accessor system.\n       *\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_initializeProperties',\n      value: function _initializeProperties() {\n        // Capture instance properties; these will be set into accessors\n        // during first flush. Don't set them here, since we want\n        // these to overwrite defaults/constructor assignments\n        for (var p in this.__dataHasAccessor) {\n          if (this.hasOwnProperty(p)) {\n            this.__dataInstanceProps = this.__dataInstanceProps || {};\n            this.__dataInstanceProps[p] = this[p];\n            delete this[p];\n          }\n        }\n      }\n\n      /**\n       * Called at ready time with bag of instance properties that overwrote\n       * accessors when the element upgraded.\n       *\n       * The default implementation sets these properties back into the\n       * setter at ready time.  This method is provided as an override\n       * point for customizing or providing more efficient initialization.\n       *\n       * @param {Object} props Bag of property values that were overwritten\n       *   when creating property accessors.\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_initializeInstanceProperties',\n      value: function _initializeInstanceProperties(props) {\n        Object.assign(this, props);\n      }\n\n      /**\n       * Updates the local storage for a property (via `_setPendingProperty`)\n       * and enqueues a `_proeprtiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_setProperty',\n      value: function _setProperty(property, value) {\n        if (this._setPendingProperty(property, value)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Returns the value for the given property.\n       * @param {string} property Name of property\n       * @return {*} Value for the given property\n       * @protected\n       */\n\n    }, {\n      key: '_getProperty',\n      value: function _getProperty(property) {\n        return this.__data[property];\n      }\n\n      /* eslint-disable no-unused-vars */\n      /**\n       * Updates the local storage for a property, records the previous value,\n       * and adds it to the set of \"pending changes\" that will be passed to the\n       * `_propertiesChanged` callback.  This method does not enqueue the\n       * `_propertiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @param {boolean=} ext Not used here; affordance for closure\n       * @return {boolean} Returns true if the property changed\n       * @protected\n       */\n\n    }, {\n      key: '_setPendingProperty',\n      value: function _setPendingProperty(property, value, ext) {\n        var old = this.__data[property];\n        var changed = this._shouldPropertyChange(property, value, old);\n        if (changed) {\n          if (!this.__dataPending) {\n            this.__dataPending = {};\n            this.__dataOld = {};\n          }\n          // Ensure old is captured from the last turn\n          if (this.__dataOld && !(property in this.__dataOld)) {\n            this.__dataOld[property] = old;\n          }\n          this.__data[property] = value;\n          this.__dataPending[property] = value;\n        }\n        return changed;\n      }\n      /* eslint-enable */\n\n      /**\n       * Marks the properties as invalid, and enqueues an async\n       * `_propertiesChanged` callback.\n       *\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_invalidateProperties',\n      value: function _invalidateProperties() {\n        var _this2 = this;\n\n        if (!this.__dataInvalid && this.__dataReady) {\n          this.__dataInvalid = true;\n          microtask.run(function () {\n            if (_this2.__dataInvalid) {\n              _this2.__dataInvalid = false;\n              _this2._flushProperties();\n            }\n          });\n        }\n      }\n\n      /**\n       * Call to enable property accessor processing. Before this method is\n       * called accessor values will be set but side effects are\n       * queued. When called, any pending side effects occur immediately.\n       * For elements, generally `connectedCallback` is a normal spot to do so.\n       * It is safe to call this method multiple times as it only turns on\n       * property accessors once.\n       *\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_enableProperties',\n      value: function _enableProperties() {\n        if (!this.__dataEnabled) {\n          this.__dataEnabled = true;\n          if (this.__dataInstanceProps) {\n            this._initializeInstanceProperties(this.__dataInstanceProps);\n            this.__dataInstanceProps = null;\n          }\n          this.ready();\n        }\n      }\n\n      /**\n       * Calls the `_propertiesChanged` callback with the current set of\n       * pending changes (and old values recorded when pending changes were\n       * set), and resets the pending set of changes. Generally, this method\n       * should not be called in user code.\n       *\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_flushProperties',\n      value: function _flushProperties() {\n        var props = this.__data;\n        var changedProps = this.__dataPending;\n        var old = this.__dataOld;\n        if (this._shouldPropertiesChange(props, changedProps, old)) {\n          this.__dataPending = null;\n          this.__dataOld = null;\n          this._propertiesChanged(props, changedProps, old);\n        }\n      }\n\n      /**\n       * Called in `_flushProperties` to determine if `_propertiesChanged`\n       * should be called. The default implementation returns true if\n       * properties are pending. Override to customize when\n       * `_propertiesChanged` is called.\n       * @param {!Object} currentProps Bag of all current accessor values\n       * @param {!Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {!Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @return {boolean} true if changedProps is truthy\n       */\n\n    }, {\n      key: '_shouldPropertiesChange',\n      value: function _shouldPropertiesChange(currentProps, changedProps, oldProps) {\n        // eslint-disable-line no-unused-vars\n        return Boolean(changedProps);\n      }\n\n      /**\n       * Callback called when any properties with accessors created via\n       * `_createPropertyAccessor` have been set.\n       *\n       * @param {!Object} currentProps Bag of all current accessor values\n       * @param {!Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {!Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_propertiesChanged',\n      value: function _propertiesChanged(currentProps, changedProps, oldProps) {} // eslint-disable-line no-unused-vars\n\n\n      /**\n       * Method called to determine whether a property value should be\n       * considered as a change and cause the `_propertiesChanged` callback\n       * to be enqueued.\n       *\n       * The default implementation returns `true` if a strict equality\n       * check fails. The method always returns false for `NaN`.\n       *\n       * Override this method to e.g. provide stricter checking for\n       * Objects/Arrays when using immutable patterns.\n       *\n       * @param {string} property Property name\n       * @param {*} value New property value\n       * @param {*} old Previous property value\n       * @return {boolean} Whether the property should be considered a change\n       *   and enqueue a `_proeprtiesChanged` callback\n       * @protected\n       */\n\n    }, {\n      key: '_shouldPropertyChange',\n      value: function _shouldPropertyChange(property, value, old) {\n        return (\n          // Strict equality check\n          old !== value && (\n          // This ensures (old==NaN, value==NaN) always returns false\n          old === old || value === value)\n        );\n      }\n\n      /**\n       * Implements native Custom Elements `attributeChangedCallback` to\n       * set an attribute value to a property via `_attributeToProperty`.\n       *\n       * @param {string} name Name of attribute that changed\n       * @param {?string} old Old attribute value\n       * @param {?string} value New attribute value\n       * @return {void}\n       * @suppress {missingProperties} Super may or may not implement the callback\n       */\n\n    }, {\n      key: 'attributeChangedCallback',\n      value: function attributeChangedCallback(name, old, value) {\n        if (old !== value) {\n          this._attributeToProperty(name, value);\n        }\n        if (_get(PropertiesChanged.prototype.__proto__ || Object.getPrototypeOf(PropertiesChanged.prototype), 'attributeChangedCallback', this)) {\n          _get(PropertiesChanged.prototype.__proto__ || Object.getPrototypeOf(PropertiesChanged.prototype), 'attributeChangedCallback', this).call(this, name, old, value);\n        }\n      }\n\n      /**\n       * Deserializes an attribute to its associated property.\n       *\n       * This method calls the `_deserializeValue` method to convert the string to\n       * a typed value.\n       *\n       * @param {string} attribute Name of attribute to deserialize.\n       * @param {?string} value of the attribute.\n       * @param {*=} type type to deserialize to, defaults to the value\n       * returned from `typeForProperty`\n       * @return {void}\n       */\n\n    }, {\n      key: '_attributeToProperty',\n      value: function _attributeToProperty(attribute, value, type) {\n        if (!this.__serializing) {\n          var map = this.__dataAttributes;\n          var property = map && map[attribute] || attribute;\n          this[property] = this._deserializeValue(value, type || this.constructor.typeForProperty(property));\n        }\n      }\n\n      /**\n       * Serializes a property to its associated attribute.\n       *\n       * @suppress {invalidCasts} Closure can't figure out `this` is an element.\n       *\n       * @param {string} property Property name to reflect.\n       * @param {string=} attribute Attribute name to reflect to.\n       * @param {*=} value Property value to refect.\n       * @return {void}\n       */\n\n    }, {\n      key: '_propertyToAttribute',\n      value: function _propertyToAttribute(property, attribute, value) {\n        this.__serializing = true;\n        value = arguments.length < 3 ? this[property] : value;\n        this._valueToNodeAttribute( /** @type {!HTMLElement} */this, value, attribute || this.constructor.attributeNameForProperty(property));\n        this.__serializing = false;\n      }\n\n      /**\n       * Sets a typed value to an HTML attribute on a node.\n       *\n       * This method calls the `_serializeValue` method to convert the typed\n       * value to a string.  If the `_serializeValue` method returns `undefined`,\n       * the attribute will be removed (this is the default for boolean\n       * type `false`).\n       *\n       * @param {Element} node Element to set attribute to.\n       * @param {*} value Value to serialize.\n       * @param {string} attribute Attribute name to serialize to.\n       * @return {void}\n       */\n\n    }, {\n      key: '_valueToNodeAttribute',\n      value: function _valueToNodeAttribute(node, value, attribute) {\n        var str = this._serializeValue(value);\n        if (str === undefined) {\n          node.removeAttribute(attribute);\n        } else {\n          node.setAttribute(attribute, str);\n        }\n      }\n\n      /**\n       * Converts a typed JavaScript value to a string.\n       *\n       * This method is called when setting JS property values to\n       * HTML attributes.  Users may override this method to provide\n       * serialization for custom types.\n       *\n       * @param {*} value Property value to serialize.\n       * @return {string | undefined} String serialized from the provided\n       * property  value.\n       */\n\n    }, {\n      key: '_serializeValue',\n      value: function _serializeValue(value) {\n        switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n          case 'boolean':\n            return value ? '' : undefined;\n          default:\n            return value != null ? value.toString() : undefined;\n        }\n      }\n\n      /**\n       * Converts a string to a typed JavaScript value.\n       *\n       * This method is called when reading HTML attribute values to\n       * JS properties.  Users may override this method to provide\n       * deserialization for custom `type`s. Types for `Boolean`, `String`,\n       * and `Number` convert attributes to the expected types.\n       *\n       * @param {?string} value Value to deserialize.\n       * @param {*=} type Type to deserialize the string to.\n       * @return {*} Typed value deserialized from the provided string.\n       */\n\n    }, {\n      key: '_deserializeValue',\n      value: function _deserializeValue(value, type) {\n        switch (type) {\n          case Boolean:\n            return value !== null;\n          case Number:\n            return Number(value);\n          default:\n            return value;\n        }\n      }\n    }]);\n\n    return PropertiesChanged;\n  }(superClass);\n\n  return PropertiesChanged;\n});\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/mixins/properties-changed.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/properties-mixin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/properties-mixin.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PropertiesMixin = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\n__webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n\nvar _mixin = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@polymer/polymer/lib/utils/mixin.js\");\n\nvar _propertiesChanged = __webpack_require__(/*! ./properties-changed.js */ \"./node_modules/@polymer/polymer/lib/mixins/properties-changed.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Creates a copy of `props` with each property normalized such that\n * upgraded it is an object with at least a type property { type: Type}.\n *\n * @param {Object} props Properties to normalize\n * @return {Object} Copy of input `props` with normalized properties that\n * are in the form {type: Type}\n * @private\n */\nfunction normalizeProperties(props) {\n  var output = {};\n  for (var p in props) {\n    var o = props[p];\n    output[p] = typeof o === 'function' ? { type: o } : o;\n  }\n  return output;\n}\n\nvar PropertiesMixin = exports.PropertiesMixin = (0, _mixin.dedupingMixin)(function (superClass) {\n\n  /**\n   * @constructor\n   * @extends {superClass}\n   * @implements {Polymer_PropertiesChanged}\n   */\n  var base = (0, _propertiesChanged.PropertiesChanged)(superClass);\n\n  /**\n   * Returns the super class constructor for the given class, if it is an\n   * instance of the PropertiesMixin.\n   *\n   * @param {!PropertiesMixinConstructor} constructor PropertiesMixin constructor\n   * @return {PropertiesMixinConstructor} Super class constructor\n   */\n  function superPropertiesClass(constructor) {\n    var superCtor = Object.getPrototypeOf(constructor);\n\n    // Note, the `PropertiesMixin` class below only refers to the class\n    // generated by this call to the mixin; the instanceof test only works\n    // because the mixin is deduped and guaranteed only to apply once, hence\n    // all constructors in a proto chain will see the same `PropertiesMixin`\n    return superCtor.prototype instanceof PropertiesMixin ?\n    /** @type {PropertiesMixinConstructor} */superCtor : null;\n  }\n\n  /**\n   * Returns a memoized version of the `properties` object for the\n   * given class. Properties not in object format are converted to at\n   * least {type}.\n   *\n   * @param {PropertiesMixinConstructor} constructor PropertiesMixin constructor\n   * @return {Object} Memoized properties object\n   */\n  function ownProperties(constructor) {\n    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', constructor))) {\n      var props = null;\n\n      if (constructor.hasOwnProperty(JSCompiler_renameProperty('properties', constructor)) && constructor.properties) {\n        props = normalizeProperties(constructor.properties);\n      }\n\n      constructor.__ownProperties = props;\n    }\n    return constructor.__ownProperties;\n  }\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @extends {base}\n   * @implements {Polymer_PropertiesMixin}\n   * @unrestricted\n   */\n\n  var PropertiesMixin = function (_base) {\n    _inherits(PropertiesMixin, _base);\n\n    function PropertiesMixin() {\n      _classCallCheck(this, PropertiesMixin);\n\n      return _possibleConstructorReturn(this, (PropertiesMixin.__proto__ || Object.getPrototypeOf(PropertiesMixin)).apply(this, arguments));\n    }\n\n    _createClass(PropertiesMixin, [{\n      key: '_initializeProperties',\n\n\n      /**\n       * Overrides `PropertiesChanged` method and adds a call to\n       * `finalize` which lazily configures the element's property accessors.\n       * @override\n       * @return {void}\n       */\n      value: function _initializeProperties() {\n        this.constructor.finalize();\n        _get(PropertiesMixin.prototype.__proto__ || Object.getPrototypeOf(PropertiesMixin.prototype), '_initializeProperties', this).call(this);\n      }\n\n      /**\n       * Called when the element is added to a document.\n       * Calls `_enableProperties` to turn on property system from\n       * `PropertiesChanged`.\n       * @suppress {missingProperties} Super may or may not implement the callback\n       * @return {void}\n       */\n\n    }, {\n      key: 'connectedCallback',\n      value: function connectedCallback() {\n        if (_get(PropertiesMixin.prototype.__proto__ || Object.getPrototypeOf(PropertiesMixin.prototype), 'connectedCallback', this)) {\n          _get(PropertiesMixin.prototype.__proto__ || Object.getPrototypeOf(PropertiesMixin.prototype), 'connectedCallback', this).call(this);\n        }\n        this._enableProperties();\n      }\n\n      /**\n       * Called when the element is removed from a document\n       * @suppress {missingProperties} Super may or may not implement the callback\n       * @return {void}\n       */\n\n    }, {\n      key: 'disconnectedCallback',\n      value: function disconnectedCallback() {\n        if (_get(PropertiesMixin.prototype.__proto__ || Object.getPrototypeOf(PropertiesMixin.prototype), 'disconnectedCallback', this)) {\n          _get(PropertiesMixin.prototype.__proto__ || Object.getPrototypeOf(PropertiesMixin.prototype), 'disconnectedCallback', this).call(this);\n        }\n      }\n    }], [{\n      key: 'finalize',\n\n\n      /**\n       * Finalizes an element definition, including ensuring any super classes\n       * are also finalized. This includes ensuring property\n       * accessors exist on the element prototype. This method calls\n       * `_finalizeClass` to finalize each constructor in the prototype chain.\n       * @return {void}\n       */\n      value: function finalize() {\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('__finalized', this))) {\n          var superCtor = superPropertiesClass( /** @type {PropertiesMixinConstructor} */this);\n          if (superCtor) {\n            superCtor.finalize();\n          }\n          this.__finalized = true;\n          this._finalizeClass();\n        }\n      }\n\n      /**\n       * Finalize an element class. This includes ensuring property\n       * accessors exist on the element prototype. This method is called by\n       * `finalize` and finalizes the class constructor.\n       *\n       * @protected\n       */\n\n    }, {\n      key: '_finalizeClass',\n      value: function _finalizeClass() {\n        var props = ownProperties( /** @type {PropertiesMixinConstructor} */this);\n        if (props) {\n          this.createProperties(props);\n        }\n      }\n\n      /**\n       * Returns a memoized version of all properties, including those inherited\n       * from super classes. Properties not in object format are converted to\n       * at least {type}.\n       *\n       * @return {Object} Object containing properties for this class\n       * @protected\n       */\n\n    }, {\n      key: 'typeForProperty',\n\n\n      /**\n       * Overrides `PropertiesChanged` method to return type specified in the\n       * static `properties` object for the given property.\n       * @param {string} name Name of property\n       * @return {*} Type to which to deserialize attribute\n       *\n       * @protected\n       */\n      value: function typeForProperty(name) {\n        var info = this._properties[name];\n        return info && info.type;\n      }\n    }, {\n      key: 'observedAttributes',\n\n\n      /**\n       * Implements standard custom elements getter to observes the attributes\n       * listed in `properties`.\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n      get: function get() {\n        var _this2 = this;\n\n        var props = this._properties;\n        return props ? Object.keys(props).map(function (p) {\n          return _this2.attributeNameForProperty(p);\n        }) : [];\n      }\n    }, {\n      key: '_properties',\n      get: function get() {\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('__properties', this))) {\n          var superCtor = superPropertiesClass( /** @type {PropertiesMixinConstructor} */this);\n          this.__properties = Object.assign({}, superCtor && superCtor._properties, ownProperties( /** @type {PropertiesMixinConstructor} */this));\n        }\n        return this.__properties;\n      }\n    }]);\n\n    return PropertiesMixin;\n  }(base);\n\n  return PropertiesMixin;\n});\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/mixins/properties-mixin.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/property-accessors.js":
/*!************************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/property-accessors.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PropertyAccessors = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\n__webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n\nvar _mixin = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@polymer/polymer/lib/utils/mixin.js\");\n\nvar _caseMap = __webpack_require__(/*! ../utils/case-map.js */ \"./node_modules/@polymer/polymer/lib/utils/case-map.js\");\n\nvar caseMap$0 = _interopRequireWildcard(_caseMap);\n\nvar _propertiesChanged = __webpack_require__(/*! ./properties-changed.js */ \"./node_modules/@polymer/polymer/lib/mixins/properties-changed.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar caseMap = caseMap$0;\n\n// Save map of native properties; this forms a blacklist or properties\n// that won't have their values \"saved\" by `saveAccessorValue`, since\n// reading from an HTMLElement accessor from the context of a prototype throws\nvar nativeProperties = {};\nvar proto = HTMLElement.prototype;\nwhile (proto) {\n  var props = Object.getOwnPropertyNames(proto);\n  for (var i = 0; i < props.length; i++) {\n    nativeProperties[props[i]] = true;\n  }\n  proto = Object.getPrototypeOf(proto);\n}\n\n/**\n * Used to save the value of a property that will be overridden with\n * an accessor. If the `model` is a prototype, the values will be saved\n * in `__dataProto`, and it's up to the user (or downstream mixin) to\n * decide how/when to set these values back into the accessors.\n * If `model` is already an instance (it has a `__data` property), then\n * the value will be set as a pending property, meaning the user should\n * call `_invalidateProperties` or `_flushProperties` to take effect\n *\n * @param {Object} model Prototype or instance\n * @param {string} property Name of property\n * @return {void}\n * @private\n */\nfunction saveAccessorValue(model, property) {\n  // Don't read/store value for any native properties since they could throw\n  if (!nativeProperties[property]) {\n    var value = model[property];\n    if (value !== undefined) {\n      if (model.__data) {\n        // Adding accessor to instance; update the property\n        // It is the user's responsibility to call _flushProperties\n        model._setPendingProperty(property, value);\n      } else {\n        // Adding accessor to proto; save proto's value for instance-time use\n        if (!model.__dataProto) {\n          model.__dataProto = {};\n        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {\n          model.__dataProto = Object.create(model.__dataProto);\n        }\n        model.__dataProto[property] = value;\n      }\n    }\n  }\n}\n\nvar PropertyAccessors = exports.PropertyAccessors = (0, _mixin.dedupingMixin)(function (superClass) {\n\n  /**\n   * @constructor\n   * @extends {superClass}\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   */\n  var base = (0, _propertiesChanged.PropertiesChanged)(superClass);\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyAccessors}\n   * @extends {base}\n   * @unrestricted\n   */\n\n  var PropertyAccessors = function (_base) {\n    _inherits(PropertyAccessors, _base);\n\n    function PropertyAccessors() {\n      _classCallCheck(this, PropertyAccessors);\n\n      return _possibleConstructorReturn(this, (PropertyAccessors.__proto__ || Object.getPrototypeOf(PropertyAccessors)).apply(this, arguments));\n    }\n\n    _createClass(PropertyAccessors, [{\n      key: '_initializeProperties',\n\n\n      /**\n       * Overrides PropertiesChanged implementation to initialize values for\n       * accessors created for values that already existed on the element\n       * prototype.\n       *\n       * @return {void}\n       * @protected\n       */\n      value: function _initializeProperties() {\n        if (this.__dataProto) {\n          this._initializeProtoProperties(this.__dataProto);\n          this.__dataProto = null;\n        }\n        _get(PropertyAccessors.prototype.__proto__ || Object.getPrototypeOf(PropertyAccessors.prototype), '_initializeProperties', this).call(this);\n      }\n\n      /**\n       * Called at instance time with bag of properties that were overwritten\n       * by accessors on the prototype when accessors were created.\n       *\n       * The default implementation sets these properties back into the\n       * setter at instance time.  This method is provided as an override\n       * point for customizing or providing more efficient initialization.\n       *\n       * @param {Object} props Bag of property values that were overwritten\n       *   when creating property accessors.\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_initializeProtoProperties',\n      value: function _initializeProtoProperties(props) {\n        for (var p in props) {\n          this._setProperty(p, props[p]);\n        }\n      }\n\n      /**\n       * Ensures the element has the given attribute. If it does not,\n       * assigns the given value to the attribute.\n       *\n       * @suppress {invalidCasts} Closure can't figure out `this` is infact an element\n       *\n       * @param {string} attribute Name of attribute to ensure is set.\n       * @param {string} value of the attribute.\n       * @return {void}\n       */\n\n    }, {\n      key: '_ensureAttribute',\n      value: function _ensureAttribute(attribute, value) {\n        var el = /** @type {!HTMLElement} */this;\n        if (!el.hasAttribute(attribute)) {\n          this._valueToNodeAttribute(el, value, attribute);\n        }\n      }\n\n      /**\n       * Overrides PropertiesChanged implemention to serialize objects as JSON.\n       *\n       * @param {*} value Property value to serialize.\n       * @return {string | undefined} String serialized from the provided property value.\n       */\n\n    }, {\n      key: '_serializeValue',\n      value: function _serializeValue(value) {\n        /* eslint-disable no-fallthrough */\n        switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n          case 'object':\n            if (value instanceof Date) {\n              return value.toString();\n            } else if (value) {\n              try {\n                return JSON.stringify(value);\n              } catch (x) {\n                return '';\n              }\n            }\n\n          default:\n            return _get(PropertyAccessors.prototype.__proto__ || Object.getPrototypeOf(PropertyAccessors.prototype), '_serializeValue', this).call(this, value);\n        }\n      }\n\n      /**\n       * Converts a string to a typed JavaScript value.\n       *\n       * This method is called by Polymer when reading HTML attribute values to\n       * JS properties.  Users may override this method on Polymer element\n       * prototypes to provide deserialization for custom `type`s.  Note,\n       * the `type` argument is the value of the `type` field provided in the\n       * `properties` configuration object for a given property, and is\n       * by convention the constructor for the type to deserialize.\n       *\n       *\n       * @param {?string} value Attribute value to deserialize.\n       * @param {*=} type Type to deserialize the string to.\n       * @return {*} Typed value deserialized from the provided string.\n       */\n\n    }, {\n      key: '_deserializeValue',\n      value: function _deserializeValue(value, type) {\n        /**\n         * @type {*}\n         */\n        var outValue = void 0;\n        switch (type) {\n          case Object:\n            try {\n              outValue = JSON.parse( /** @type {string} */value);\n            } catch (x) {\n              // allow non-JSON literals like Strings and Numbers\n              outValue = value;\n            }\n            break;\n          case Array:\n            try {\n              outValue = JSON.parse( /** @type {string} */value);\n            } catch (x) {\n              outValue = null;\n              console.warn('Polymer::Attributes: couldn\\'t decode Array as JSON: ' + value);\n            }\n            break;\n          case Date:\n            outValue = isNaN(value) ? String(value) : Number(value);\n            outValue = new Date(outValue);\n            break;\n          default:\n            outValue = _get(PropertyAccessors.prototype.__proto__ || Object.getPrototypeOf(PropertyAccessors.prototype), '_deserializeValue', this).call(this, value, type);\n            break;\n        }\n        return outValue;\n      }\n      /* eslint-enable no-fallthrough */\n\n      /**\n       * Overrides PropertiesChanged implementation to save existing prototype\n       * property value so that it can be reset.\n       * @param {string} property Name of the property\n       * @param {boolean=} readOnly When true, no setter is created\n       *\n       * When calling on a prototype, any overwritten values are saved in\n       * `__dataProto`, and it is up to the subclasser to decide how/when\n       * to set those properties back into the accessor.  When calling on an\n       * instance, the overwritten value is set via `_setPendingProperty`,\n       * and the user should call `_invalidateProperties` or `_flushProperties`\n       * for the values to take effect.\n       * @protected\n       * @return {void}\n       */\n\n    }, {\n      key: '_definePropertyAccessor',\n      value: function _definePropertyAccessor(property, readOnly) {\n        saveAccessorValue(this, property);\n        _get(PropertyAccessors.prototype.__proto__ || Object.getPrototypeOf(PropertyAccessors.prototype), '_definePropertyAccessor', this).call(this, property, readOnly);\n      }\n\n      /**\n       * Returns true if this library created an accessor for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if an accessor was created\n       */\n\n    }, {\n      key: '_hasAccessor',\n      value: function _hasAccessor(property) {\n        return this.__dataHasAccessor && this.__dataHasAccessor[property];\n      }\n\n      /**\n       * Returns true if the specified property has a pending change.\n       *\n       * @param {string} prop Property name\n       * @return {boolean} True if property has a pending change\n       * @protected\n       */\n\n    }, {\n      key: '_isPropertyPending',\n      value: function _isPropertyPending(prop) {\n        return Boolean(this.__dataPending && prop in this.__dataPending);\n      }\n    }], [{\n      key: 'createPropertiesForAttributes',\n\n\n      /**\n       * Generates property accessors for all attributes in the standard\n       * static `observedAttributes` array.\n       *\n       * Attribute names are mapped to property names using the `dash-case` to\n       * `camelCase` convention\n       *\n       * @return {void}\n       */\n      value: function createPropertiesForAttributes() {\n        var a$ = this.observedAttributes;\n        for (var _i = 0; _i < a$.length; _i++) {\n          this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[_i]));\n        }\n      }\n\n      /**\n       * Returns an attribute name that corresponds to the given property.\n       * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.\n       * @param {string} property Property to convert\n       * @return {string} Attribute name corresponding to the given property.\n       *\n       * @protected\n       */\n\n    }, {\n      key: 'attributeNameForProperty',\n      value: function attributeNameForProperty(property) {\n        return caseMap.camelToDashCase(property);\n      }\n    }]);\n\n    return PropertyAccessors;\n  }(base);\n\n  return PropertyAccessors;\n});\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/mixins/property-accessors.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/property-effects.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/property-effects.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PropertyEffects = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n__webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n\nvar _mixin = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@polymer/polymer/lib/utils/mixin.js\");\n\nvar _path = __webpack_require__(/*! ../utils/path.js */ \"./node_modules/@polymer/polymer/lib/utils/path.js\");\n\nvar _caseMap = __webpack_require__(/*! ../utils/case-map.js */ \"./node_modules/@polymer/polymer/lib/utils/case-map.js\");\n\nvar caseMap = _interopRequireWildcard(_caseMap);\n\nvar _propertyAccessors = __webpack_require__(/*! ./property-accessors.js */ \"./node_modules/@polymer/polymer/lib/mixins/property-accessors.js\");\n\nvar _templateStamp = __webpack_require__(/*! ./template-stamp.js */ \"./node_modules/@polymer/polymer/lib/mixins/template-stamp.js\");\n\nvar _settings = __webpack_require__(/*! ../utils/settings.js */ \"./node_modules/@polymer/polymer/lib/utils/settings.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/** @const {Object} */\nvar CaseMap = caseMap;\n\n// Monotonically increasing unique ID used for de-duping effects triggered\n// from multiple properties in the same turn\nvar dedupeId = 0;\n\n/**\n * Property effect types; effects are stored on the prototype using these keys\n * @enum {string}\n */\nvar TYPES = {\n  COMPUTE: '__computeEffects',\n  REFLECT: '__reflectEffects',\n  NOTIFY: '__notifyEffects',\n  PROPAGATE: '__propagateEffects',\n  OBSERVE: '__observeEffects',\n  READ_ONLY: '__readOnly'\n};\n\n/** @const {string} */\nvar capitalAttributeRegex = /[A-Z]/;\n\n/**\n * @typedef {{\n * name: (string | undefined),\n * structured: (boolean | undefined),\n * wildcard: (boolean | undefined)\n * }}\n */\nvar DataTrigger = void 0; //eslint-disable-line no-unused-vars\n\n/**\n * @typedef {{\n * info: ?,\n * trigger: (!DataTrigger | undefined),\n * fn: (!Function | undefined)\n * }}\n */\nvar DataEffect = void 0; //eslint-disable-line no-unused-vars\n\nvar PropertyEffectsType = void 0; //eslint-disable-line no-unused-vars\n\n/**\n * Ensures that the model has an own-property map of effects for the given type.\n * The model may be a prototype or an instance.\n *\n * Property effects are stored as arrays of effects by property in a map,\n * by named type on the model. e.g.\n *\n *   __computeEffects: {\n *     foo: [ ... ],\n *     bar: [ ... ]\n *   }\n *\n * If the model does not yet have an effect map for the type, one is created\n * and returned.  If it does, but it is not an own property (i.e. the\n * prototype had effects), the the map is deeply cloned and the copy is\n * set on the model and returned, ready for new effects to be added.\n *\n * @param {Object} model Prototype or instance\n * @param {string} type Property effect type\n * @return {Object} The own-property map of effects for the given type\n * @private\n */\nfunction ensureOwnEffectMap(model, type) {\n  var effects = model[type];\n  if (!effects) {\n    effects = model[type] = {};\n  } else if (!model.hasOwnProperty(type)) {\n    effects = model[type] = Object.create(model[type]);\n    for (var p in effects) {\n      var protoFx = effects[p];\n      var instFx = effects[p] = Array(protoFx.length);\n      for (var i = 0; i < protoFx.length; i++) {\n        instFx[i] = protoFx[i];\n      }\n    }\n  }\n  return effects;\n}\n\n// -- effects ----------------------------------------------\n\n/**\n * Runs all effects of a given type for the given set of property changes\n * on an instance.\n *\n * @param {!PropertyEffectsType} inst The instance with effects to run\n * @param {Object} effects Object map of property-to-Array of effects\n * @param {Object} props Bag of current property changes\n * @param {Object=} oldProps Bag of previous values for changed properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\nfunction runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {\n  if (effects) {\n    var ran = false;\n    var id = dedupeId++;\n    for (var prop in props) {\n      if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {\n        ran = true;\n      }\n    }\n    return ran;\n  }\n  return false;\n}\n\n/**\n * Runs a list of effects for a given property.\n *\n * @param {!PropertyEffectsType} inst The instance with effects to run\n * @param {Object} effects Object map of property-to-Array of effects\n * @param {number} dedupeId Counter used for de-duping effects\n * @param {string} prop Name of changed property\n * @param {*} props Changed properties\n * @param {*} oldProps Old properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\nfunction runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {\n  var ran = false;\n  var rootProperty = hasPaths ? (0, _path.root)(prop) : prop;\n  var fxs = effects[rootProperty];\n  if (fxs) {\n    for (var i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {\n      if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n        if (fx.info) {\n          fx.info.lastRun = dedupeId;\n        }\n        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n        ran = true;\n      }\n    }\n  }\n  return ran;\n}\n\n/**\n * Determines whether a property/path that has changed matches the trigger\n * criteria for an effect.  A trigger is a descriptor with the following\n * structure, which matches the descriptors returned from `parseArg`.\n * e.g. for `foo.bar.*`:\n * ```\n * trigger: {\n *   name: 'a.b',\n *   structured: true,\n *   wildcard: true\n * }\n * ```\n * If no trigger is given, the path is deemed to match.\n *\n * @param {string} path Path or property that changed\n * @param {DataTrigger} trigger Descriptor\n * @return {boolean} Whether the path matched the trigger\n */\nfunction pathMatchesTrigger(path, trigger) {\n  if (trigger) {\n    var triggerPath = trigger.name;\n    return triggerPath == path || trigger.structured && (0, _path.isAncestor)(triggerPath, path) || trigger.wildcard && (0, _path.isDescendant)(triggerPath, path);\n  } else {\n    return true;\n  }\n}\n\n/**\n * Implements the \"observer\" effect.\n *\n * Calls the method with `info.methodName` on the instance, passing the\n * new and old values.\n *\n * @param {!PropertyEffectsType} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\nfunction runObserverEffect(inst, property, props, oldProps, info) {\n  var fn = typeof info.method === \"string\" ? inst[info.method] : info.method;\n  var changedProp = info.property;\n  if (fn) {\n    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);\n  } else if (!info.dynamicFn) {\n    console.warn('observer method `' + info.method + '` not defined');\n  }\n}\n\n/**\n * Runs \"notify\" effects for a set of changed properties.\n *\n * This method differs from the generic `runEffects` method in that it\n * will dispatch path notification events in the case that the property\n * changed was a path and the root property for that path didn't have a\n * \"notify\" effect.  This is to maintain 1.0 behavior that did not require\n * `notify: true` to ensure object sub-property notifications were\n * sent.\n *\n * @param {!PropertyEffectsType} inst The instance with effects to run\n * @param {Object} notifyProps Bag of properties to notify\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {\n  // Notify\n  var fxs = inst[TYPES.NOTIFY];\n  var notified = void 0;\n  var id = dedupeId++;\n  // Try normal notify effects; if none, fall back to try path notification\n  for (var prop in notifyProps) {\n    if (notifyProps[prop]) {\n      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {\n        notified = true;\n      } else if (hasPaths && notifyPath(inst, prop, props)) {\n        notified = true;\n      }\n    }\n  }\n  // Flush host if we actually notified and host was batching\n  // And the host has already initialized clients; this prevents\n  // an issue with a host observing data changes before clients are ready.\n  var host = void 0;\n  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {\n    host._invalidateProperties();\n  }\n}\n\n/**\n * Dispatches {property}-changed events with path information in the detail\n * object to indicate a sub-path of the property was changed.\n *\n * @param {!PropertyEffectsType} inst The element from which to fire the event\n * @param {string} path The path that was changed\n * @param {Object} props Bag of current property changes\n * @return {boolean} Returns true if the path was notified\n * @private\n */\nfunction notifyPath(inst, path, props) {\n  var rootProperty = (0, _path.root)(path);\n  if (rootProperty !== path) {\n    var eventName = (0, _caseMap.camelToDashCase)(rootProperty) + '-changed';\n    dispatchNotifyEvent(inst, eventName, props[path], path);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Dispatches {property}-changed events to indicate a property (or path)\n * changed.\n *\n * @param {!PropertyEffectsType} inst The element from which to fire the event\n * @param {string} eventName The name of the event to send ('{property}-changed')\n * @param {*} value The value of the changed property\n * @param {string | null | undefined} path If a sub-path of this property changed, the path\n *   that changed (optional).\n * @return {void}\n * @private\n * @suppress {invalidCasts}\n */\nfunction dispatchNotifyEvent(inst, eventName, value, path) {\n  var detail = {\n    value: value,\n    queueProperty: true\n  };\n  if (path) {\n    detail.path = path;\n  }\n  /** @type {!HTMLElement} */inst.dispatchEvent(new CustomEvent(eventName, { detail: detail }));\n}\n\n/**\n * Implements the \"notify\" effect.\n *\n * Dispatches a non-bubbling event named `info.eventName` on the instance\n * with a detail object containing the new `value`.\n *\n * @param {!PropertyEffectsType} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {\n  var rootProperty = hasPaths ? (0, _path.root)(property) : property;\n  var path = rootProperty != property ? property : null;\n  var value = path ? (0, _path.get)(inst, path) : inst.__data[property];\n  if (path && value === undefined) {\n    value = props[property]; // specifically for .splices\n  }\n  dispatchNotifyEvent(inst, info.eventName, value, path);\n}\n\n/**\n * Handler function for 2-way notification events. Receives context\n * information captured in the `addNotifyListener` closure from the\n * `__notifyListeners` metadata.\n *\n * Sets the value of the notified property to the host property or path.  If\n * the event contained path information, translate that path to the host\n * scope's name for that path first.\n *\n * @param {CustomEvent} event Notification event (e.g. '<property>-changed')\n * @param {!PropertyEffectsType} inst Host element instance handling the notification event\n * @param {string} fromProp Child element property that was bound\n * @param {string} toPath Host property/path that was bound\n * @param {boolean} negate Whether the binding was negated\n * @return {void}\n * @private\n */\nfunction handleNotification(event, inst, fromProp, toPath, negate) {\n  var value = void 0;\n  var detail = /** @type {Object} */event.detail;\n  var fromPath = detail && detail.path;\n  if (fromPath) {\n    toPath = (0, _path.translate)(fromProp, toPath, fromPath);\n    value = detail && detail.value;\n  } else {\n    value = event.target[fromProp];\n  }\n  value = negate ? !value : value;\n  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {\n    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {\n      inst._invalidateProperties();\n    }\n  }\n}\n\n/**\n * Implements the \"reflect\" effect.\n *\n * Sets the attribute named `info.attrName` to the given property value.\n *\n * @param {!PropertyEffectsType} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\nfunction runReflectEffect(inst, property, props, oldProps, info) {\n  var value = inst.__data[property];\n  if (_settings.sanitizeDOMValue) {\n    value = (0, _settings.sanitizeDOMValue)(value, info.attrName, 'attribute', /** @type {Node} */inst);\n  }\n  inst._propertyToAttribute(property, info.attrName, value);\n}\n\n/**\n * Runs \"computed\" effects for a set of changed properties.\n *\n * This method differs from the generic `runEffects` method in that it\n * continues to run computed effects based on the output of each pass until\n * there are no more newly computed properties.  This ensures that all\n * properties that will be computed by the initial set of changes are\n * computed before other effects (binding propagation, observers, and notify)\n * run.\n *\n * @param {!PropertyEffectsType} inst The instance the effect will be run on\n * @param {!Object} changedProps Bag of changed properties\n * @param {!Object} oldProps Bag of previous values for changed properties\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runComputedEffects(inst, changedProps, oldProps, hasPaths) {\n  var computeEffects = inst[TYPES.COMPUTE];\n  if (computeEffects) {\n    var inputProps = changedProps;\n    while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {\n      Object.assign(oldProps, inst.__dataOld);\n      Object.assign(changedProps, inst.__dataPending);\n      inputProps = inst.__dataPending;\n      inst.__dataPending = null;\n    }\n  }\n}\n\n/**\n * Implements the \"computed property\" effect by running the method with the\n * values of the arguments specified in the `info` object and setting the\n * return value to the computed property specified.\n *\n * @param {!PropertyEffectsType} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\nfunction runComputedEffect(inst, property, props, oldProps, info) {\n  var result = runMethodEffect(inst, property, props, oldProps, info);\n  var computedProp = info.methodInfo;\n  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {\n    inst._setPendingProperty(computedProp, result, true);\n  } else {\n    inst[computedProp] = result;\n  }\n}\n\n/**\n * Computes path changes based on path links set up using the `linkPaths`\n * API.\n *\n * @param {!PropertyEffectsType} inst The instance whose props are changing\n * @param {string | !Array<(string|number)>} path Path that has changed\n * @param {*} value Value of changed path\n * @return {void}\n * @private\n */\nfunction computeLinkedPaths(inst, path, value) {\n  var links = inst.__dataLinkedPaths;\n  if (links) {\n    var link = void 0;\n    for (var a in links) {\n      var b = links[a];\n      if ((0, _path.isDescendant)(a, path)) {\n        link = (0, _path.translate)(a, b, path);\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      } else if ((0, _path.isDescendant)(b, path)) {\n        link = (0, _path.translate)(b, a, path);\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      }\n    }\n  }\n}\n\n// -- bindings ----------------------------------------------\n\n/**\n * Adds binding metadata to the current `nodeInfo`, and binding effects\n * for all part dependencies to `templateInfo`.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {NodeInfo} nodeInfo Node metadata for current template node\n * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'\n * @param {string} target Target property name\n * @param {!Array<!BindingPart>} parts Array of binding part metadata\n * @param {string=} literal Literal text surrounding binding parts (specified\n *   only for 'property' bindings, since these must be initialized as part\n *   of boot-up)\n * @return {void}\n * @private\n */\nfunction addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {\n  // Create binding metadata and add to nodeInfo\n  nodeInfo.bindings = nodeInfo.bindings || [];\n  var /** Binding */binding = { kind: kind, target: target, parts: parts, literal: literal, isCompound: parts.length !== 1 };\n  nodeInfo.bindings.push(binding);\n  // Add listener info to binding metadata\n  if (shouldAddListener(binding)) {\n    var _binding$parts$ = binding.parts[0],\n        event = _binding$parts$.event,\n        negate = _binding$parts$.negate;\n\n    binding.listenerEvent = event || CaseMap.camelToDashCase(target) + '-changed';\n    binding.listenerNegate = negate;\n  }\n  // Add \"propagate\" property effects to templateInfo\n  var index = templateInfo.nodeInfoList.length;\n  for (var i = 0; i < binding.parts.length; i++) {\n    var part = binding.parts[i];\n    part.compoundIndex = i;\n    addEffectForBindingPart(constructor, templateInfo, binding, part, index);\n  }\n}\n\n/**\n * Adds property effects to the given `templateInfo` for the given binding\n * part.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @param {number} index Index into `nodeInfoList` for this node\n * @return {void}\n */\nfunction addEffectForBindingPart(constructor, templateInfo, binding, part, index) {\n  if (!part.literal) {\n    if (binding.kind === 'attribute' && binding.target[0] === '-') {\n      console.warn('Cannot set attribute ' + binding.target + ' because \"-\" is not a valid attribute starting character');\n    } else {\n      var dependencies = part.dependencies;\n      var info = { index: index, binding: binding, part: part, evaluator: constructor };\n      for (var j = 0; j < dependencies.length; j++) {\n        var trigger = dependencies[j];\n        if (typeof trigger == 'string') {\n          trigger = parseArg(trigger);\n          trigger.wildcard = true;\n        }\n        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {\n          fn: runBindingEffect,\n          info: info, trigger: trigger\n        });\n      }\n    }\n  }\n}\n\n/**\n * Implements the \"binding\" (property/path binding) effect.\n *\n * Note that binding syntax is overridable via `_parseBindings` and\n * `_evaluateBinding`.  This method will call `_evaluateBinding` for any\n * non-literal parts returned from `_parseBindings`.  However,\n * there is no support for _path_ bindings via custom binding parts,\n * as this is specific to Polymer's path binding syntax.\n *\n * @param {!PropertyEffectsType} inst The instance the effect will be run on\n * @param {string} path Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @param {Array} nodeList List of nodes associated with `nodeInfoList` template\n *   metadata\n * @return {void}\n * @private\n */\nfunction runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {\n  var node = nodeList[info.index];\n  var binding = info.binding;\n  var part = info.part;\n  // Subpath notification: transform path and set to client\n  // e.g.: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop\n  if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {\n    var value = props[path];\n    path = (0, _path.translate)(part.source, binding.target, path);\n    if (node._setPendingPropertyOrPath(path, value, false, true)) {\n      inst._enqueueClient(node);\n    }\n  } else {\n    var _value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);\n    // Propagate value to child\n    applyBindingValue(inst, node, binding, part, _value);\n  }\n}\n\n/**\n * Sets the value for an \"binding\" (binding) effect to a node,\n * either as a property or attribute.\n *\n * @param {!PropertyEffectsType} inst The instance owning the binding effect\n * @param {Node} node Target node for binding\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @param {*} value Value to set\n * @return {void}\n * @private\n */\nfunction applyBindingValue(inst, node, binding, part, value) {\n  value = computeBindingValue(node, value, binding, part);\n  if (_settings.sanitizeDOMValue) {\n    value = (0, _settings.sanitizeDOMValue)(value, binding.target, binding.kind, node);\n  }\n  if (binding.kind == 'attribute') {\n    // Attribute binding\n    inst._valueToNodeAttribute( /** @type {Element} */node, value, binding.target);\n  } else {\n    // Property binding\n    var prop = binding.target;\n    if (node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[prop]) {\n      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {\n        if (node._setPendingProperty(prop, value)) {\n          inst._enqueueClient(node);\n        }\n      }\n    } else {\n      inst._setUnmanagedPropertyToNode(node, prop, value);\n    }\n  }\n}\n\n/**\n * Transforms an \"binding\" effect value based on compound & negation\n * effect metadata, as well as handling for special-case properties\n *\n * @param {Node} node Node the value will be set to\n * @param {*} value Value to set\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @return {*} Transformed value to set\n * @private\n */\nfunction computeBindingValue(node, value, binding, part) {\n  if (binding.isCompound) {\n    var storage = node.__dataCompoundStorage[binding.target];\n    storage[part.compoundIndex] = value;\n    value = storage.join('');\n  }\n  if (binding.kind !== 'attribute') {\n    // Some browsers serialize `undefined` to `\"undefined\"`\n    if (binding.target === 'textContent' || binding.target === 'value' && (node.localName === 'input' || node.localName === 'textarea')) {\n      value = value == undefined ? '' : value;\n    }\n  }\n  return value;\n}\n\n/**\n * Returns true if a binding's metadata meets all the requirements to allow\n * 2-way binding, and therefore a `<property>-changed` event listener should be\n * added:\n * - used curly braces\n * - is a property (not attribute) binding\n * - is not a textContent binding\n * - is not compound\n *\n * @param {!Binding} binding Binding metadata\n * @return {boolean} True if 2-way listener should be added\n * @private\n */\nfunction shouldAddListener(binding) {\n  return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';\n}\n\n/**\n * Setup compound binding storage structures, notify listeners, and dataHost\n * references onto the bound nodeList.\n *\n * @param {!PropertyEffectsType} inst Instance that bas been previously bound\n * @param {TemplateInfo} templateInfo Template metadata\n * @return {void}\n * @private\n */\nfunction setupBindings(inst, templateInfo) {\n  // Setup compound storage, dataHost, and notify listeners\n  var nodeList = templateInfo.nodeList,\n      nodeInfoList = templateInfo.nodeInfoList;\n\n  if (nodeInfoList.length) {\n    for (var i = 0; i < nodeInfoList.length; i++) {\n      var info = nodeInfoList[i];\n      var node = nodeList[i];\n      var bindings = info.bindings;\n      if (bindings) {\n        for (var _i = 0; _i < bindings.length; _i++) {\n          var binding = bindings[_i];\n          setupCompoundStorage(node, binding);\n          addNotifyListener(node, inst, binding);\n        }\n      }\n      node.__dataHost = inst;\n    }\n  }\n}\n\n/**\n * Initializes `__dataCompoundStorage` local storage on a bound node with\n * initial literal data for compound bindings, and sets the joined\n * literal parts to the bound property.\n *\n * When changes to compound parts occur, they are first set into the compound\n * storage array for that property, and then the array is joined to result in\n * the final value set to the property/attribute.\n *\n * @param {Node} node Bound node to initialize\n * @param {Binding} binding Binding metadata\n * @return {void}\n * @private\n */\nfunction setupCompoundStorage(node, binding) {\n  if (binding.isCompound) {\n    // Create compound storage map\n    var storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});\n    var parts = binding.parts;\n    // Copy literals from parts into storage for this binding\n    var literals = new Array(parts.length);\n    for (var j = 0; j < parts.length; j++) {\n      literals[j] = parts[j].literal;\n    }\n    var target = binding.target;\n    storage[target] = literals;\n    // Configure properties with their literal parts\n    if (binding.literal && binding.kind == 'property') {\n      node[target] = binding.literal;\n    }\n  }\n}\n\n/**\n * Adds a 2-way binding notification event listener to the node specified\n *\n * @param {Object} node Child element to add listener to\n * @param {!PropertyEffectsType} inst Host element instance to handle notification event\n * @param {Binding} binding Binding metadata\n * @return {void}\n * @private\n */\nfunction addNotifyListener(node, inst, binding) {\n  if (binding.listenerEvent) {\n    var part = binding.parts[0];\n    node.addEventListener(binding.listenerEvent, function (e) {\n      handleNotification(e, inst, binding.target, part.source, part.negate);\n    });\n  }\n}\n\n// -- for method-based effects (complexObserver & computed) --------------\n\n/**\n * Adds property effects for each argument in the method signature (and\n * optionally, for the method name if `dynamic` is true) that calls the\n * provided effect function.\n *\n * @param {Element | Object} model Prototype or instance\n * @param {!MethodSignature} sig Method signature metadata\n * @param {string} type Type of property effect to add\n * @param {Function} effectFn Function to run when arguments change\n * @param {*=} methodInfo Effect-specific information to be included in\n *   method effect metadata\n * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n *   method names should be included as a dependency to the effect. Note,\n *   defaults to true if the signature is static (sig.static is true).\n * @return {void}\n * @private\n */\nfunction createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {\n  dynamicFn = sig.static || dynamicFn && ((typeof dynamicFn === 'undefined' ? 'undefined' : _typeof(dynamicFn)) !== 'object' || dynamicFn[sig.methodName]);\n  var info = {\n    methodName: sig.methodName,\n    args: sig.args,\n    methodInfo: methodInfo,\n    dynamicFn: dynamicFn\n  };\n  for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {\n    if (!arg.literal) {\n      model._addPropertyEffect(arg.rootProperty, type, {\n        fn: effectFn, info: info, trigger: arg\n      });\n    }\n  }\n  if (dynamicFn) {\n    model._addPropertyEffect(sig.methodName, type, {\n      fn: effectFn, info: info\n    });\n  }\n}\n\n/**\n * Calls a method with arguments marshaled from properties on the instance\n * based on the method signature contained in the effect metadata.\n *\n * Multi-property observers, computed properties, and inline computing\n * functions call this function to invoke the method, then use the return\n * value accordingly.\n *\n * @param {!PropertyEffectsType} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {*} Returns the return value from the method invocation\n * @private\n */\nfunction runMethodEffect(inst, property, props, oldProps, info) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  var context = inst._methodHost || inst;\n  var fn = context[info.methodName];\n  if (fn) {\n    var args = marshalArgs(inst.__data, info.args, property, props);\n    return fn.apply(context, args);\n  } else if (!info.dynamicFn) {\n    console.warn('method `' + info.methodName + '` not defined');\n  }\n}\n\nvar emptyArray = [];\n\n// Regular expressions used for binding\nvar IDENT = '(?:' + '[a-zA-Z_$][\\\\w.:$\\\\-*]*' + ')';\nvar NUMBER = '(?:' + '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';\nvar SQUOTE_STRING = '(?:' + '\\'(?:[^\\'\\\\\\\\]|\\\\\\\\.)*\\'' + ')';\nvar DQUOTE_STRING = '(?:' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')';\nvar STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';\nvar ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\\\s*' + ')';\nvar ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\\\s*' + ARGUMENT + ')*' + ')';\nvar ARGUMENT_LIST = '(?:' + '\\\\(\\\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\\\)\\\\s*' + ')';\nvar BINDING = '(' + IDENT + '\\\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3\nvar OPEN_BRACKET = '(\\\\[\\\\[|{{)' + '\\\\s*';\nvar CLOSE_BRACKET = '(?:]]|}})';\nvar NEGATE = '(?:(!)\\\\s*)?'; // Group 2\nvar EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;\nvar bindingRegex = new RegExp(EXPRESSION, \"g\");\n\n/**\n * Create a string from binding parts of all the literal parts\n *\n * @param {!Array<BindingPart>} parts All parts to stringify\n * @return {string} String made from the literal parts\n */\nfunction literalFromParts(parts) {\n  var s = '';\n  for (var i = 0; i < parts.length; i++) {\n    var literal = parts[i].literal;\n    s += literal || '';\n  }\n  return s;\n}\n\n/**\n * Parses an expression string for a method signature, and returns a metadata\n * describing the method in terms of `methodName`, `static` (whether all the\n * arguments are literals), and an array of `args`\n *\n * @param {string} expression The expression to parse\n * @return {?MethodSignature} The method metadata object if a method expression was\n *   found, otherwise `undefined`\n * @private\n */\nfunction parseMethod(expression) {\n  // tries to match valid javascript property names\n  var m = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\n  if (m) {\n    var methodName = m[1];\n    var sig = { methodName: methodName, static: true, args: emptyArray };\n    if (m[2].trim()) {\n      // replace escaped commas with comma entity, split on un-escaped commas\n      var args = m[2].replace(/\\\\,/g, '&comma;').split(',');\n      return parseArgs(args, sig);\n    } else {\n      return sig;\n    }\n  }\n  return null;\n}\n\n/**\n * Parses an array of arguments and sets the `args` property of the supplied\n * signature metadata object. Sets the `static` property to false if any\n * argument is a non-literal.\n *\n * @param {!Array<string>} argList Array of argument names\n * @param {!MethodSignature} sig Method signature metadata object\n * @return {!MethodSignature} The updated signature metadata object\n * @private\n */\nfunction parseArgs(argList, sig) {\n  sig.args = argList.map(function (rawArg) {\n    var arg = parseArg(rawArg);\n    if (!arg.literal) {\n      sig.static = false;\n    }\n    return arg;\n  }, this);\n  return sig;\n}\n\n/**\n * Parses an individual argument, and returns an argument metadata object\n * with the following fields:\n *\n *   {\n *     value: 'prop',        // property/path or literal value\n *     literal: false,       // whether argument is a literal\n *     structured: false,    // whether the property is a path\n *     rootProperty: 'prop', // the root property of the path\n *     wildcard: false       // whether the argument was a wildcard '.*' path\n *   }\n *\n * @param {string} rawArg The string value of the argument\n * @return {!MethodArg} Argument metadata object\n * @private\n */\nfunction parseArg(rawArg) {\n  // clean up whitespace\n  var arg = rawArg.trim()\n  // replace comma entity with comma\n  .replace(/&comma;/g, ',')\n  // repair extra escape sequences; note only commas strictly need\n  // escaping, but we allow any other char to be escaped since its\n  // likely users will do this\n  .replace(/\\\\(.)/g, '\\$1');\n  // basic argument descriptor\n  var a = {\n    name: arg,\n    value: '',\n    literal: false\n  };\n  // detect literal value (must be String or Number)\n  var fc = arg[0];\n  if (fc === '-') {\n    fc = arg[1];\n  }\n  if (fc >= '0' && fc <= '9') {\n    fc = '#';\n  }\n  switch (fc) {\n    case \"'\":\n    case '\"':\n      a.value = arg.slice(1, -1);\n      a.literal = true;\n      break;\n    case '#':\n      a.value = Number(arg);\n      a.literal = true;\n      break;\n  }\n  // if not literal, look for structured path\n  if (!a.literal) {\n    a.rootProperty = (0, _path.root)(arg);\n    // detect structured path (has dots)\n    a.structured = (0, _path.isPath)(arg);\n    if (a.structured) {\n      a.wildcard = arg.slice(-2) == '.*';\n      if (a.wildcard) {\n        a.name = arg.slice(0, -2);\n      }\n    }\n  }\n  return a;\n}\n\n/**\n * Gather the argument values for a method specified in the provided array\n * of argument metadata.\n *\n * The `path` and `value` arguments are used to fill in wildcard descriptor\n * when the method is being called as a result of a path notification.\n *\n * @param {Object} data Instance data storage object to read properties from\n * @param {!Array<!MethodArg>} args Array of argument metadata\n * @param {string} path Property/path name that triggered the method effect\n * @param {Object} props Bag of current property changes\n * @return {Array<*>} Array of argument values\n * @private\n */\nfunction marshalArgs(data, args, path, props) {\n  var values = [];\n  for (var i = 0, l = args.length; i < l; i++) {\n    var arg = args[i];\n    var name = arg.name;\n    var v = void 0;\n    if (arg.literal) {\n      v = arg.value;\n    } else {\n      if (arg.structured) {\n        v = (0, _path.get)(data, name);\n        // when data is not stored e.g. `splices`\n        if (v === undefined) {\n          v = props[name];\n        }\n      } else {\n        v = data[name];\n      }\n    }\n    if (arg.wildcard) {\n      // Only send the actual path changed info if the change that\n      // caused the observer to run matched the wildcard\n      var baseChanged = name.indexOf(path + '.') === 0;\n      var matches = path.indexOf(name) === 0 && !baseChanged;\n      values[i] = {\n        path: matches ? path : name,\n        value: matches ? props[path] : v,\n        base: v\n      };\n    } else {\n      values[i] = v;\n    }\n  }\n  return values;\n}\n\n// data api\n\n/**\n * Sends array splice notifications (`.splices` and `.length`)\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!PropertyEffectsType} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {Array} splices Array of splice records\n * @return {void}\n * @private\n */\nfunction _notifySplices(inst, array, path, splices) {\n  var splicesPath = path + '.splices';\n  inst.notifyPath(splicesPath, { indexSplices: splices });\n  inst.notifyPath(path + '.length', array.length);\n  // Null here to allow potentially large splice records to be GC'ed.\n  inst.__data[splicesPath] = { indexSplices: null };\n}\n\n/**\n * Creates a splice record and sends an array splice notification for\n * the described mutation\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!PropertyEffectsType} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {number} index Index at which the array mutation occurred\n * @param {number} addedCount Number of added items\n * @param {Array} removed Array of removed items\n * @return {void}\n * @private\n */\nfunction notifySplice(inst, array, path, index, addedCount, removed) {\n  _notifySplices(inst, array, path, [{\n    index: index,\n    addedCount: addedCount,\n    removed: removed,\n    object: array,\n    type: 'splice'\n  }]);\n}\n\n/**\n * Returns an upper-cased version of the string.\n *\n * @param {string} name String to uppercase\n * @return {string} Uppercased string\n * @private\n */\nfunction upper(name) {\n  return name[0].toUpperCase() + name.substring(1);\n}\n\nvar PropertyEffects = exports.PropertyEffects = (0, _mixin.dedupingMixin)(function (superClass) {\n\n  /**\n   * @constructor\n   * @extends {superClass}\n   * @implements {Polymer_PropertyAccessors}\n   * @implements {Polymer_TemplateStamp}\n   * @unrestricted\n   */\n  var propertyEffectsBase = (0, _templateStamp.TemplateStamp)((0, _propertyAccessors.PropertyAccessors)(superClass));\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyEffects}\n   * @extends {propertyEffectsBase}\n   * @unrestricted\n   */\n\n  var PropertyEffects = function (_propertyEffectsBase) {\n    _inherits(PropertyEffects, _propertyEffectsBase);\n\n    function PropertyEffects() {\n      _classCallCheck(this, PropertyEffects);\n\n      /** @type {boolean} */\n      // Used to identify users of this mixin, ala instanceof\n      var _this = _possibleConstructorReturn(this, (PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects)).call(this));\n\n      _this.__isPropertyEffectsClient = true;\n      /** @type {number} */\n      // NOTE: used to track re-entrant calls to `_flushProperties`\n      // path changes dirty check against `__dataTemp` only during one \"turn\"\n      // and are cleared when `__dataCounter` returns to 0.\n      _this.__dataCounter = 0;\n      /** @type {boolean} */\n      _this.__dataClientsReady;\n      /** @type {Array} */\n      _this.__dataPendingClients;\n      /** @type {Object} */\n      _this.__dataToNotify;\n      /** @type {Object} */\n      _this.__dataLinkedPaths;\n      /** @type {boolean} */\n      _this.__dataHasPaths;\n      /** @type {Object} */\n      _this.__dataCompoundStorage;\n      /** @type {Polymer_PropertyEffects} */\n      _this.__dataHost;\n      /** @type {!Object} */\n      _this.__dataTemp;\n      /** @type {boolean} */\n      _this.__dataClientsInitialized;\n      /** @type {!Object} */\n      _this.__data;\n      /** @type {!Object} */\n      _this.__dataPending;\n      /** @type {!Object} */\n      _this.__dataOld;\n      /** @type {Object} */\n      _this.__computeEffects;\n      /** @type {Object} */\n      _this.__reflectEffects;\n      /** @type {Object} */\n      _this.__notifyEffects;\n      /** @type {Object} */\n      _this.__propagateEffects;\n      /** @type {Object} */\n      _this.__observeEffects;\n      /** @type {Object} */\n      _this.__readOnly;\n      /** @type {!TemplateInfo} */\n      _this.__templateInfo;\n      return _this;\n    }\n\n    _createClass(PropertyEffects, [{\n      key: '_initializeProperties',\n\n\n      /**\n       * @return {void}\n       */\n      value: function _initializeProperties() {\n        _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_initializeProperties', this).call(this);\n        hostStack.registerHost(this);\n        this.__dataClientsReady = false;\n        this.__dataPendingClients = null;\n        this.__dataToNotify = null;\n        this.__dataLinkedPaths = null;\n        this.__dataHasPaths = false;\n        // May be set on instance prior to upgrade\n        this.__dataCompoundStorage = this.__dataCompoundStorage || null;\n        this.__dataHost = this.__dataHost || null;\n        this.__dataTemp = {};\n        this.__dataClientsInitialized = false;\n      }\n\n      /**\n       * Overrides `Polymer.PropertyAccessors` implementation to provide a\n       * more efficient implementation of initializing properties from\n       * the prototype on the instance.\n       *\n       * @override\n       * @param {Object} props Properties to initialize on the prototype\n       * @return {void}\n       */\n\n    }, {\n      key: '_initializeProtoProperties',\n      value: function _initializeProtoProperties(props) {\n        this.__data = Object.create(props);\n        this.__dataPending = Object.create(props);\n        this.__dataOld = {};\n      }\n\n      /**\n       * Overrides `Polymer.PropertyAccessors` implementation to avoid setting\n       * `_setProperty`'s `shouldNotify: true`.\n       *\n       * @override\n       * @param {Object} props Properties to initialize on the instance\n       * @return {void}\n       */\n\n    }, {\n      key: '_initializeInstanceProperties',\n      value: function _initializeInstanceProperties(props) {\n        var readOnly = this[TYPES.READ_ONLY];\n        for (var prop in props) {\n          if (!readOnly || !readOnly[prop]) {\n            this.__dataPending = this.__dataPending || {};\n            this.__dataOld = this.__dataOld || {};\n            this.__data[prop] = this.__dataPending[prop] = props[prop];\n          }\n        }\n      }\n\n      // Prototype setup ----------------------------------------\n\n      /**\n       * Equivalent to static `addPropertyEffect` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property that should trigger the effect\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_addPropertyEffect',\n      value: function _addPropertyEffect(property, type, effect) {\n        this._createPropertyAccessor(property, type == TYPES.READ_ONLY);\n        // effects are accumulated into arrays per property based on type\n        var effects = ensureOwnEffectMap(this, type)[property];\n        if (!effects) {\n          effects = this[type][property] = [];\n        }\n        effects.push(effect);\n      }\n\n      /**\n       * Removes the given property effect.\n       *\n       * @param {string} property Property the effect was associated with\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object to remove\n       * @return {void}\n       */\n\n    }, {\n      key: '_removePropertyEffect',\n      value: function _removePropertyEffect(property, type, effect) {\n        var effects = ensureOwnEffectMap(this, type)[property];\n        var idx = effects.indexOf(effect);\n        if (idx >= 0) {\n          effects.splice(idx, 1);\n        }\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a property effect\n       * of a certain type.\n       *\n       * @param {string} property Property name\n       * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n\n    }, {\n      key: '_hasPropertyEffect',\n      value: function _hasPropertyEffect(property, type) {\n        var effects = this[type];\n        return Boolean(effects && effects[property]);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"read only\"\n       * accessor for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n\n    }, {\n      key: '_hasReadOnlyEffect',\n      value: function _hasReadOnlyEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.READ_ONLY);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"notify\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n\n    }, {\n      key: '_hasNotifyEffect',\n      value: function _hasNotifyEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.NOTIFY);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"reflect to attribute\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n\n    }, {\n      key: '_hasReflectEffect',\n      value: function _hasReflectEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.REFLECT);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"computed\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n\n    }, {\n      key: '_hasComputedEffect',\n      value: function _hasComputedEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.COMPUTE);\n      }\n\n      // Runtime ----------------------------------------\n\n      /**\n       * Sets a pending property or path.  If the root property of the path in\n       * question had no accessor, the path is set, otherwise it is enqueued\n       * via `_setPendingProperty`.\n       *\n       * This function isolates relatively expensive functionality necessary\n       * for the public API (`set`, `setProperties`, `notifyPath`, and property\n       * change listeners via {{...}} bindings), such that it is only done\n       * when paths enter the system, and not at every propagation step.  It\n       * also sets a `__dataHasPaths` flag on the instance which is used to\n       * fast-path slower path-matching code in the property effects host paths.\n       *\n       * `path` can be a path string or array of path parts as accepted by the\n       * public API.\n       *\n       * @param {string | !Array<number|string>} path Path to set\n       * @param {*} value Value to set\n       * @param {boolean=} shouldNotify Set to true if this change should\n       *  cause a property notification event dispatch\n       * @param {boolean=} isPathNotification If the path being set is a path\n       *   notification of an already changed value, as opposed to a request\n       *   to set and notify the change.  In the latter `false` case, a dirty\n       *   check is performed and then the value is set to the path before\n       *   enqueuing the pending property change.\n       * @return {boolean} Returns true if the property/path was enqueued in\n       *   the pending changes bag.\n       * @protected\n       */\n\n    }, {\n      key: '_setPendingPropertyOrPath',\n      value: function _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {\n        if (isPathNotification || (0, _path.root)(Array.isArray(path) ? path[0] : path) !== path) {\n          // Dirty check changes being set to a path against the actual object,\n          // since this is the entry point for paths into the system; from here\n          // the only dirty checks are against the `__dataTemp` cache to prevent\n          // duplicate work in the same turn only. Note, if this was a notification\n          // of a change already set to a path (isPathNotification: true),\n          // we always let the change through and skip the `set` since it was\n          // already dirty checked at the point of entry and the underlying\n          // object has already been updated\n          if (!isPathNotification) {\n            var old = (0, _path.get)(this, path);\n            path = /** @type {string} */(0, _path.set)(this, path, value);\n            // Use property-accessor's simpler dirty check\n            if (!path || !_get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_shouldPropertyChange', this).call(this, path, value, old)) {\n              return false;\n            }\n          }\n          this.__dataHasPaths = true;\n          if (this._setPendingProperty( /**@type{string}*/path, value, shouldNotify)) {\n            computeLinkedPaths(this, path, value);\n            return true;\n          }\n        } else {\n          if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {\n            return this._setPendingProperty( /**@type{string}*/path, value, shouldNotify);\n          } else {\n            this[path] = value;\n          }\n        }\n        return false;\n      }\n\n      /**\n       * Applies a value to a non-Polymer element/node's property.\n       *\n       * The implementation makes a best-effort at binding interop:\n       * Some native element properties have side-effects when\n       * re-setting the same value (e.g. setting `<input>.value` resets the\n       * cursor position), so we do a dirty-check before setting the value.\n       * However, for better interop with non-Polymer custom elements that\n       * accept objects, we explicitly re-set object changes coming from the\n       * Polymer world (which may include deep object changes without the\n       * top reference changing), erring on the side of providing more\n       * information.\n       *\n       * Users may override this method to provide alternate approaches.\n       *\n       * @param {!Node} node The node to set a property on\n       * @param {string} prop The property to set\n       * @param {*} value The value to set\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_setUnmanagedPropertyToNode',\n      value: function _setUnmanagedPropertyToNode(node, prop, value) {\n        // It is a judgment call that resetting primitives is\n        // \"bad\" and resettings objects is also \"good\"; alternatively we could\n        // implement a whitelist of tag & property values that should never\n        // be reset (e.g. <input>.value && <select>.value)\n        if (value !== node[prop] || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {\n          node[prop] = value;\n        }\n      }\n\n      /**\n       * Overrides the `PropertiesChanged` implementation to introduce special\n       * dirty check logic depending on the property & value being set:\n       *\n       * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})\n       *    Stored in `__dataTemp`, dirty checked against `__dataTemp`\n       * 2. Object set to simple property (e.g. 'prop': {...})\n       *    Stored in `__dataTemp` and `__data`, dirty checked against\n       *    `__dataTemp` by default implementation of `_shouldPropertyChange`\n       * 3. Primitive value set to simple property (e.g. 'prop': 42)\n       *    Stored in `__data`, dirty checked against `__data`\n       *\n       * The dirty-check is important to prevent cycles due to two-way\n       * notification, but paths and objects are only dirty checked against any\n       * previous value set during this turn via a \"temporary cache\" that is\n       * cleared when the last `_propertiesChanged` exits. This is so:\n       * a. any cached array paths (e.g. 'array.3.prop') may be invalidated\n       *    due to array mutations like shift/unshift/splice; this is fine\n       *    since path changes are dirty-checked at user entry points like `set`\n       * b. dirty-checking for objects only lasts one turn to allow the user\n       *    to mutate the object in-place and re-set it with the same identity\n       *    and have all sub-properties re-propagated in a subsequent turn.\n       *\n       * The temp cache is not necessarily sufficient to prevent invalid array\n       * paths, since a splice can happen during the same turn (with pathological\n       * user code); we could introduce a \"fixup\" for temporarily cached array\n       * paths if needed: https://github.com/Polymer/polymer/issues/4227\n       *\n       * @override\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @param {boolean=} shouldNotify True if property should fire notification\n       *   event (applies only for `notify: true` properties)\n       * @return {boolean} Returns true if the property changed\n       */\n\n    }, {\n      key: '_setPendingProperty',\n      value: function _setPendingProperty(property, value, shouldNotify) {\n        var isPath = this.__dataHasPaths && (0, _path.isPath)(property);\n        var prevProps = isPath ? this.__dataTemp : this.__data;\n        if (this._shouldPropertyChange(property, value, prevProps[property])) {\n          if (!this.__dataPending) {\n            this.__dataPending = {};\n            this.__dataOld = {};\n          }\n          // Ensure old is captured from the last turn\n          if (!(property in this.__dataOld)) {\n            this.__dataOld[property] = this.__data[property];\n          }\n          // Paths are stored in temporary cache (cleared at end of turn),\n          // which is used for dirty-checking, all others stored in __data\n          if (isPath) {\n            this.__dataTemp[property] = value;\n          } else {\n            this.__data[property] = value;\n          }\n          // All changes go into pending property bag, passed to _propertiesChanged\n          this.__dataPending[property] = value;\n          // Track properties that should notify separately\n          if (isPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {\n            this.__dataToNotify = this.__dataToNotify || {};\n            this.__dataToNotify[property] = shouldNotify;\n          }\n          return true;\n        }\n        return false;\n      }\n\n      /**\n       * Overrides base implementation to ensure all accessors set `shouldNotify`\n       * to true, for per-property notification tracking.\n       *\n       * @override\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @return {void}\n       */\n\n    }, {\n      key: '_setProperty',\n      value: function _setProperty(property, value) {\n        if (this._setPendingProperty(property, value, true)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Overrides `PropertyAccessor`'s default async queuing of\n       * `_propertiesChanged`: if `__dataReady` is false (has not yet been\n       * manually flushed), the function no-ops; otherwise flushes\n       * `_propertiesChanged` synchronously.\n       *\n       * @override\n       * @return {void}\n       */\n\n    }, {\n      key: '_invalidateProperties',\n      value: function _invalidateProperties() {\n        if (this.__dataReady) {\n          this._flushProperties();\n        }\n      }\n\n      /**\n       * Enqueues the given client on a list of pending clients, whose\n       * pending property changes can later be flushed via a call to\n       * `_flushClients`.\n       *\n       * @param {Object} client PropertyEffects client to enqueue\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_enqueueClient',\n      value: function _enqueueClient(client) {\n        this.__dataPendingClients = this.__dataPendingClients || [];\n        if (client !== this) {\n          this.__dataPendingClients.push(client);\n        }\n      }\n\n      /**\n       * Overrides superclass implementation.\n       *\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_flushProperties',\n      value: function _flushProperties() {\n        this.__dataCounter++;\n        _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_flushProperties', this).call(this);\n        this.__dataCounter--;\n      }\n\n      /**\n       * Flushes any clients previously enqueued via `_enqueueClient`, causing\n       * their `_flushProperties` method to run.\n       *\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_flushClients',\n      value: function _flushClients() {\n        if (!this.__dataClientsReady) {\n          this.__dataClientsReady = true;\n          this._readyClients();\n          // Override point where accessors are turned on; importantly,\n          // this is after clients have fully readied, providing a guarantee\n          // that any property effects occur only after all clients are ready.\n          this.__dataReady = true;\n        } else {\n          this.__enableOrFlushClients();\n        }\n      }\n\n      // NOTE: We ensure clients either enable or flush as appropriate. This\n      // handles two corner cases:\n      // (1) clients flush properly when connected/enabled before the host\n      // enables; e.g.\n      //   (a) Templatize stamps with no properties and does not flush and\n      //   (b) the instance is inserted into dom and\n      //   (c) then the instance flushes.\n      // (2) clients enable properly when not connected/enabled when the host\n      // flushes; e.g.\n      //   (a) a template is runtime stamped and not yet connected/enabled\n      //   (b) a host sets a property, causing stamped dom to flush\n      //   (c) the stamped dom enables.\n\n    }, {\n      key: '__enableOrFlushClients',\n      value: function __enableOrFlushClients() {\n        var clients = this.__dataPendingClients;\n        if (clients) {\n          this.__dataPendingClients = null;\n          for (var i = 0; i < clients.length; i++) {\n            var client = clients[i];\n            if (!client.__dataEnabled) {\n              client._enableProperties();\n            } else if (client.__dataPending) {\n              client._flushProperties();\n            }\n          }\n        }\n      }\n\n      /**\n       * Perform any initial setup on client dom. Called before the first\n       * `_flushProperties` call on client dom and before any element\n       * observers are called.\n       *\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_readyClients',\n      value: function _readyClients() {\n        this.__enableOrFlushClients();\n      }\n\n      /**\n       * Sets a bag of property changes to this instance, and\n       * synchronously processes all effects of the properties as a batch.\n       *\n       * Property names must be simple properties, not paths.  Batched\n       * path propagation is not supported.\n       *\n       * @param {Object} props Bag of one or more key-value pairs whose key is\n       *   a property and value is the new value to set for that property.\n       * @param {boolean=} setReadOnly When true, any private values set in\n       *   `props` will be set. By default, `setProperties` will not set\n       *   `readOnly: true` root properties.\n       * @return {void}\n       * @public\n       */\n\n    }, {\n      key: 'setProperties',\n      value: function setProperties(props, setReadOnly) {\n        for (var path in props) {\n          if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {\n            //TODO(kschaaf): explicitly disallow paths in setProperty?\n            // wildcard observers currently only pass the first changed path\n            // in the `info` object, and you could do some odd things batching\n            // paths, e.g. {'foo.bar': {...}, 'foo': null}\n            this._setPendingPropertyOrPath(path, props[path], true);\n          }\n        }\n        this._invalidateProperties();\n      }\n\n      /**\n       * Overrides `PropertyAccessors` so that property accessor\n       * side effects are not enabled until after client dom is fully ready.\n       * Also calls `_flushClients` callback to ensure client dom is enabled\n       * that was not enabled as a result of flushing properties.\n       *\n       * @override\n       * @return {void}\n       */\n\n    }, {\n      key: 'ready',\n      value: function ready() {\n        // It is important that `super.ready()` is not called here as it\n        // immediately turns on accessors. Instead, we wait until `readyClients`\n        // to enable accessors to provide a guarantee that clients are ready\n        // before processing any accessors side effects.\n        this._flushProperties();\n        // If no data was pending, `_flushProperties` will not `flushClients`\n        // so ensure this is done.\n        if (!this.__dataClientsReady) {\n          this._flushClients();\n        }\n        // Before ready, client notifications do not trigger _flushProperties.\n        // Therefore a flush is necessary here if data has been set.\n        if (this.__dataPending) {\n          this._flushProperties();\n        }\n      }\n\n      /**\n       * Implements `PropertyAccessors`'s properties changed callback.\n       *\n       * Runs each class of effects for the batch of changed properties in\n       * a specific order (compute, propagate, reflect, observe, notify).\n       *\n       * @param {!Object} currentProps Bag of all current accessor values\n       * @param {!Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {!Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @return {void}\n       */\n\n    }, {\n      key: '_propertiesChanged',\n      value: function _propertiesChanged(currentProps, changedProps, oldProps) {\n        // ----------------------------\n        // let c = Object.getOwnPropertyNames(changedProps || {});\n        // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);\n        // if (window.debug) { debugger; }\n        // ----------------------------\n        var hasPaths = this.__dataHasPaths;\n        this.__dataHasPaths = false;\n        // Compute properties\n        runComputedEffects(this, changedProps, oldProps, hasPaths);\n        // Clear notify properties prior to possible reentry (propagate, observe),\n        // but after computing effects have a chance to add to them\n        var notifyProps = this.__dataToNotify;\n        this.__dataToNotify = null;\n        // Propagate properties to clients\n        this._propagatePropertyChanges(changedProps, oldProps, hasPaths);\n        // Flush clients\n        this._flushClients();\n        // Reflect properties\n        runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);\n        // Observe properties\n        runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);\n        // Notify properties to host\n        if (notifyProps) {\n          runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);\n        }\n        // Clear temporary cache at end of turn\n        if (this.__dataCounter == 1) {\n          this.__dataTemp = {};\n        }\n        // ----------------------------\n        // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);\n        // ----------------------------\n      }\n\n      /**\n       * Called to propagate any property changes to stamped template nodes\n       * managed by this element.\n       *\n       * @param {Object} changedProps Bag of changed properties\n       * @param {Object} oldProps Bag of previous values for changed properties\n       * @param {boolean} hasPaths True with `props` contains one or more paths\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_propagatePropertyChanges',\n      value: function _propagatePropertyChanges(changedProps, oldProps, hasPaths) {\n        if (this[TYPES.PROPAGATE]) {\n          runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);\n        }\n        var templateInfo = this.__templateInfo;\n        while (templateInfo) {\n          runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);\n          templateInfo = templateInfo.nextTemplateInfo;\n        }\n      }\n\n      /**\n       * Aliases one data path as another, such that path notifications from one\n       * are routed to the other.\n       *\n       * @param {string | !Array<string|number>} to Target path to link.\n       * @param {string | !Array<string|number>} from Source path to link.\n       * @return {void}\n       * @public\n       */\n\n    }, {\n      key: 'linkPaths',\n      value: function linkPaths(to, from) {\n        to = (0, _path.normalize)(to);\n        from = (0, _path.normalize)(from);\n        this.__dataLinkedPaths = this.__dataLinkedPaths || {};\n        this.__dataLinkedPaths[to] = from;\n      }\n\n      /**\n       * Removes a data path alias previously established with `_linkPaths`.\n       *\n       * Note, the path to unlink should be the target (`to`) used when\n       * linking the paths.\n       *\n       * @param {string | !Array<string|number>} path Target path to unlink.\n       * @return {void}\n       * @public\n       */\n\n    }, {\n      key: 'unlinkPaths',\n      value: function unlinkPaths(path) {\n        path = (0, _path.normalize)(path);\n        if (this.__dataLinkedPaths) {\n          delete this.__dataLinkedPaths[path];\n        }\n      }\n\n      /**\n       * Notify that an array has changed.\n       *\n       * Example:\n       *\n       *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];\n       *     ...\n       *     this.items.splice(1, 1, {name: 'Sam'});\n       *     this.items.push({name: 'Bob'});\n       *     this.notifySplices('items', [\n       *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, object: this.items, type: 'splice' },\n       *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}\n       *     ]);\n       *\n       * @param {string} path Path that should be notified.\n       * @param {Array} splices Array of splice records indicating ordered\n       *   changes that occurred to the array. Each record should have the\n       *   following fields:\n       *    * index: index at which the change occurred\n       *    * removed: array of items that were removed from this index\n       *    * addedCount: number of new items added at this index\n       *    * object: a reference to the array in question\n       *    * type: the string literal 'splice'\n       *\n       *   Note that splice records _must_ be normalized such that they are\n       *   reported in index order (raw results from `Object.observe` are not\n       *   ordered and must be normalized/merged before notifying).\n       * @return {void}\n       * @public\n      */\n\n    }, {\n      key: 'notifySplices',\n      value: function notifySplices(path, splices) {\n        var info = { path: '' };\n        var array = /** @type {Array} */(0, _path.get)(this, path, info);\n        _notifySplices(this, array, info.path, splices);\n      }\n\n      /**\n       * Convenience method for reading a value from a path.\n       *\n       * Note, if any part in the path is undefined, this method returns\n       * `undefined` (this method does not throw when dereferencing undefined\n       * paths).\n       *\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `users.12.name` or `['users', 12, 'name']`).\n       * @param {Object=} root Root object from which the path is evaluated.\n       * @return {*} Value at the path, or `undefined` if any part of the path\n       *   is undefined.\n       * @public\n       */\n\n    }, {\n      key: 'get',\n      value: function get(path, root) {\n        return (0, _path.get)(root || this, path);\n      }\n\n      /**\n       * Convenience method for setting a value to a path and notifying any\n       * elements bound to the same path.\n       *\n       * Note, if any part in the path except for the last is undefined,\n       * this method does nothing (this method does not throw when\n       * dereferencing undefined paths).\n       *\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).\n       * @param {*} value Value to set at the specified path.\n       * @param {Object=} root Root object from which the path is evaluated.\n       *   When specified, no notification will occur.\n       * @return {void}\n       * @public\n      */\n\n    }, {\n      key: 'set',\n      value: function set(path, value, root) {\n        if (root) {\n          (0, _path.set)(root, path, value);\n        } else {\n          if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */path]) {\n            if (this._setPendingPropertyOrPath(path, value, true)) {\n              this._invalidateProperties();\n            }\n          }\n        }\n      }\n\n      /**\n       * Adds items onto the end of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string | !Array<string|number>} path Path to array.\n       * @param {...*} items Items to push onto array\n       * @return {number} New length of the array.\n       * @public\n       */\n\n    }, {\n      key: 'push',\n      value: function push(path) {\n        var info = { path: '' };\n        var array = /** @type {Array}*/(0, _path.get)(this, path, info);\n        var len = array.length;\n\n        for (var _len = arguments.length, items = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          items[_key - 1] = arguments[_key];\n        }\n\n        var ret = array.push.apply(array, items);\n        if (items.length) {\n          notifySplice(this, array, info.path, len, items.length, []);\n        }\n        return ret;\n      }\n\n      /**\n       * Removes an item from the end of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string | !Array<string|number>} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n\n    }, {\n      key: 'pop',\n      value: function pop(path) {\n        var info = { path: '' };\n        var array = /** @type {Array} */(0, _path.get)(this, path, info);\n        var hadLength = Boolean(array.length);\n        var ret = array.pop();\n        if (hadLength) {\n          notifySplice(this, array, info.path, array.length, 0, [ret]);\n        }\n        return ret;\n      }\n\n      /**\n       * Starting from the start index specified, removes 0 or more items\n       * from the array and inserts 0 or more new items in their place.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.splice`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string | !Array<string|number>} path Path to array.\n       * @param {number} start Index from which to start removing/inserting.\n       * @param {number} deleteCount Number of items to remove.\n       * @param {...*} items Items to insert into array.\n       * @return {Array} Array of removed items.\n       * @public\n       */\n\n    }, {\n      key: 'splice',\n      value: function splice(path, start, deleteCount) {\n        for (var _len2 = arguments.length, items = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n          items[_key2 - 3] = arguments[_key2];\n        }\n\n        var info = { path: '' };\n        var array = /** @type {Array} */(0, _path.get)(this, path, info);\n        // Normalize fancy native splice handling of crazy start values\n        if (start < 0) {\n          start = array.length - Math.floor(-start);\n        } else if (start) {\n          start = Math.floor(start);\n        }\n        // array.splice does different things based on the number of arguments\n        // you pass in. Therefore, array.splice(0) and array.splice(0, undefined)\n        // do different things. In the former, the whole array is cleared. In the\n        // latter, no items are removed.\n        // This means that we need to detect whether 1. one of the arguments\n        // is actually passed in and then 2. determine how many arguments\n        // we should pass on to the native array.splice\n        //\n        var ret = void 0;\n        // Omit any additional arguments if they were not passed in\n        if (arguments.length === 2) {\n          ret = array.splice(start);\n          // Either start was undefined and the others were defined, but in this\n          // case we can safely pass on all arguments\n          //\n          // Note: this includes the case where none of the arguments were passed in,\n          // e.g. this.splice('array'). However, if both start and deleteCount\n          // are undefined, array.splice will not modify the array (as expected)\n        } else {\n          ret = array.splice.apply(array, [start, deleteCount].concat(items));\n        }\n        // At the end, check whether any items were passed in (e.g. insertions)\n        // or if the return array contains items (e.g. deletions).\n        // Only notify if items were added or deleted.\n        if (items.length || ret.length) {\n          notifySplice(this, array, info.path, start, items.length, ret);\n        }\n        return ret;\n      }\n\n      /**\n       * Removes an item from the beginning of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string | !Array<string|number>} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n\n    }, {\n      key: 'shift',\n      value: function shift(path) {\n        var info = { path: '' };\n        var array = /** @type {Array} */(0, _path.get)(this, path, info);\n        var hadLength = Boolean(array.length);\n        var ret = array.shift();\n        if (hadLength) {\n          notifySplice(this, array, info.path, 0, 0, [ret]);\n        }\n        return ret;\n      }\n\n      /**\n       * Adds items onto the beginning of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string | !Array<string|number>} path Path to array.\n       * @param {...*} items Items to insert info array\n       * @return {number} New length of the array.\n       * @public\n       */\n\n    }, {\n      key: 'unshift',\n      value: function unshift(path) {\n        var info = { path: '' };\n        var array = /** @type {Array} */(0, _path.get)(this, path, info);\n\n        for (var _len3 = arguments.length, items = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          items[_key3 - 1] = arguments[_key3];\n        }\n\n        var ret = array.unshift.apply(array, items);\n        if (items.length) {\n          notifySplice(this, array, info.path, 0, items.length, []);\n        }\n        return ret;\n      }\n\n      /**\n       * Notify that a path has changed.\n       *\n       * Example:\n       *\n       *     this.item.user.name = 'Bob';\n       *     this.notifyPath('item.user.name');\n       *\n       * @param {string} path Path that should be notified.\n       * @param {*=} value Value at the path (optional).\n       * @return {void}\n       * @public\n      */\n\n    }, {\n      key: 'notifyPath',\n      value: function notifyPath(path, value) {\n        /** @type {string} */\n        var propPath = void 0;\n        if (arguments.length == 1) {\n          // Get value if not supplied\n          var info = { path: '' };\n          value = (0, _path.get)(this, path, info);\n          propPath = info.path;\n        } else if (Array.isArray(path)) {\n          // Normalize path if needed\n          propPath = (0, _path.normalize)(path);\n        } else {\n          propPath = /** @type{string} */path;\n        }\n        if (this._setPendingPropertyOrPath(propPath, value, true, true)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Equivalent to static `createReadOnlyProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @param {boolean=} protectedSetter Creates a custom protected setter\n       *   when `true`.\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_createReadOnlyProperty',\n      value: function _createReadOnlyProperty(property, protectedSetter) {\n        this._addPropertyEffect(property, TYPES.READ_ONLY);\n        if (protectedSetter) {\n          this['_set' + upper(property)] = /** @this {PropertyEffects} */function (value) {\n            this._setProperty(property, value);\n          };\n        }\n      }\n\n      /**\n       * Equivalent to static `createPropertyObserver` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @param {string|function(*,*)} method Function or name of observer method to call\n       * @param {boolean=} dynamicFn Whether the method name should be included as\n       *   a dependency to the effect.\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_createPropertyObserver',\n      value: function _createPropertyObserver(property, method, dynamicFn) {\n        var info = { property: property, method: method, dynamicFn: Boolean(dynamicFn) };\n        this._addPropertyEffect(property, TYPES.OBSERVE, {\n          fn: runObserverEffect, info: info, trigger: { name: property }\n        });\n        if (dynamicFn) {\n          this._addPropertyEffect( /** @type {string} */method, TYPES.OBSERVE, {\n            fn: runObserverEffect, info: info, trigger: { name: method }\n          });\n        }\n      }\n\n      /**\n       * Equivalent to static `createMethodObserver` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       *   whether method names should be included as a dependency to the effect.\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_createMethodObserver',\n      value: function _createMethodObserver(expression, dynamicFn) {\n        var sig = parseMethod(expression);\n        if (!sig) {\n          throw new Error(\"Malformed observer expression '\" + expression + \"'\");\n        }\n        createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);\n      }\n\n      /**\n       * Equivalent to static `createNotifyingProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_createNotifyingProperty',\n      value: function _createNotifyingProperty(property) {\n        this._addPropertyEffect(property, TYPES.NOTIFY, {\n          fn: runNotifyEffect,\n          info: {\n            eventName: CaseMap.camelToDashCase(property) + '-changed',\n            property: property\n          }\n        });\n      }\n\n      /**\n       * Equivalent to static `createReflectedProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_createReflectedProperty',\n      value: function _createReflectedProperty(property) {\n        var attr = this.constructor.attributeNameForProperty(property);\n        if (attr[0] === '-') {\n          console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');\n        } else {\n          this._addPropertyEffect(property, TYPES.REFLECT, {\n            fn: runReflectEffect,\n            info: {\n              attrName: attr\n            }\n          });\n        }\n      }\n\n      /**\n       * Equivalent to static `createComputedProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Name of computed property to set\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       *   whether method names should be included as a dependency to the effect.\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_createComputedProperty',\n      value: function _createComputedProperty(property, expression, dynamicFn) {\n        var sig = parseMethod(expression);\n        if (!sig) {\n          throw new Error(\"Malformed computed expression '\" + expression + \"'\");\n        }\n        createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);\n      }\n\n      // -- static class methods ------------\n\n      /**\n       * Ensures an accessor exists for the specified property, and adds\n       * to a list of \"property effects\" that will run when the accessor for\n       * the specified property is set.  Effects are grouped by \"type\", which\n       * roughly corresponds to a phase in effect processing.  The effect\n       * metadata should be in the following form:\n       *\n       *     {\n       *       fn: effectFunction, // Reference to function to call to perform effect\n       *       info: { ... }       // Effect metadata passed to function\n       *       trigger: {          // Optional triggering metadata; if not provided\n       *         name: string      // the property is treated as a wildcard\n       *         structured: boolean\n       *         wildcard: boolean\n       *       }\n       *     }\n       *\n       * Effects are called from `_propertiesChanged` in the following order by\n       * type:\n       *\n       * 1. COMPUTE\n       * 2. PROPAGATE\n       * 3. REFLECT\n       * 4. OBSERVE\n       * 5. NOTIFY\n       *\n       * Effect functions are called with the following signature:\n       *\n       *     effectFunction(inst, path, props, oldProps, info, hasPaths)\n       *\n       * @param {string} property Property that should trigger the effect\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_bindTemplate',\n\n\n      // -- binding ----------------------------------------------\n\n      /**\n       * Equivalent to static `bindTemplate` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * This method may be called on the prototype (for prototypical template\n       * binding, to avoid creating accessors every instance) once per prototype,\n       * and will be called with `runtimeBinding: true` by `_stampTemplate` to\n       * create and link an instance of the template metadata associated with a\n       * particular stamping.\n       *\n       * @param {!HTMLTemplateElement} template Template containing binding\n       *   bindings\n       * @param {boolean=} instanceBinding When false (default), performs\n       *   \"prototypical\" binding of the template and overwrites any previously\n       *   bound template for the class. When true (as passed from\n       *   `_stampTemplate`), the template info is instanced and linked into\n       *   the list of bound templates.\n       * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,\n       *   this is an instance of the prototypical template info\n       * @protected\n       */\n      value: function _bindTemplate(template, instanceBinding) {\n        var templateInfo = this.constructor._parseTemplate(template);\n        var wasPreBound = this.__templateInfo == templateInfo;\n        // Optimization: since this is called twice for proto-bound templates,\n        // don't attempt to recreate accessors if this template was pre-bound\n        if (!wasPreBound) {\n          for (var prop in templateInfo.propertyEffects) {\n            this._createPropertyAccessor(prop);\n          }\n        }\n        if (instanceBinding) {\n          // For instance-time binding, create instance of template metadata\n          // and link into list of templates if necessary\n          templateInfo = /** @type {!TemplateInfo} */Object.create(templateInfo);\n          templateInfo.wasPreBound = wasPreBound;\n          if (!wasPreBound && this.__templateInfo) {\n            var last = this.__templateInfoLast || this.__templateInfo;\n            this.__templateInfoLast = last.nextTemplateInfo = templateInfo;\n            templateInfo.previousTemplateInfo = last;\n            return templateInfo;\n          }\n        }\n        return this.__templateInfo = templateInfo;\n      }\n\n      /**\n       * Adds a property effect to the given template metadata, which is run\n       * at the \"propagate\" stage of `_propertiesChanged` when the template\n       * has been bound to the element via `_bindTemplate`.\n       *\n       * The `effect` object should match the format in `_addPropertyEffect`.\n       *\n       * @param {Object} templateInfo Template metadata to add effect to\n       * @param {string} prop Property that should trigger the effect\n       * @param {Object=} effect Effect metadata object\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_stampTemplate',\n\n\n      /**\n       * Stamps the provided template and performs instance-time setup for\n       * Polymer template features, including data bindings, declarative event\n       * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment\n       * is returned containing the stamped DOM, ready for insertion into the\n       * DOM.\n       *\n       * This method may be called more than once; however note that due to\n       * `shadycss` polyfill limitations, only styles from templates prepared\n       * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped\n       * to the shadow root and support CSS custom properties), and note that\n       * `ShadyCSS.prepareTemplate` may only be called once per element. As such,\n       * any styles required by in runtime-stamped templates must be included\n       * in the main element template.\n       *\n       * @param {!HTMLTemplateElement} template Template to stamp\n       * @return {!StampedTemplate} Cloned template content\n       * @override\n       * @protected\n       */\n      value: function _stampTemplate(template) {\n        // Ensures that created dom is `_enqueueClient`'d to this element so\n        // that it can be flushed on next call to `_flushProperties`\n        hostStack.beginHosting(this);\n        var dom = _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_stampTemplate', this).call(this, template);\n        hostStack.endHosting(this);\n        var templateInfo = /** @type {!TemplateInfo} */this._bindTemplate(template, true);\n        // Add template-instance-specific data to instanced templateInfo\n        templateInfo.nodeList = dom.nodeList;\n        // Capture child nodes to allow unstamping of non-prototypical templates\n        if (!templateInfo.wasPreBound) {\n          var nodes = templateInfo.childNodes = [];\n          for (var n = dom.firstChild; n; n = n.nextSibling) {\n            nodes.push(n);\n          }\n        }\n        dom.templateInfo = templateInfo;\n        // Setup compound storage, 2-way listeners, and dataHost for bindings\n        setupBindings(this, templateInfo);\n        // Flush properties into template nodes if already booted\n        if (this.__dataReady) {\n          runEffects(this, templateInfo.propertyEffects, this.__data, null, false, templateInfo.nodeList);\n        }\n        return dom;\n      }\n\n      /**\n       * Removes and unbinds the nodes previously contained in the provided\n       * DocumentFragment returned from `_stampTemplate`.\n       *\n       * @param {!StampedTemplate} dom DocumentFragment previously returned\n       *   from `_stampTemplate` associated with the nodes to be removed\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: '_removeBoundDom',\n      value: function _removeBoundDom(dom) {\n        // Unlink template info\n        var templateInfo = dom.templateInfo;\n        if (templateInfo.previousTemplateInfo) {\n          templateInfo.previousTemplateInfo.nextTemplateInfo = templateInfo.nextTemplateInfo;\n        }\n        if (templateInfo.nextTemplateInfo) {\n          templateInfo.nextTemplateInfo.previousTemplateInfo = templateInfo.previousTemplateInfo;\n        }\n        if (this.__templateInfoLast == templateInfo) {\n          this.__templateInfoLast = templateInfo.previousTemplateInfo;\n        }\n        templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;\n        // Remove stamped nodes\n        var nodes = templateInfo.childNodes;\n        for (var i = 0; i < nodes.length; i++) {\n          var node = nodes[i];\n          node.parentNode.removeChild(node);\n        }\n      }\n\n      /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`\n       * array is added to `nodeInfo` and populated with binding metadata\n       * with information capturing the binding target, and a `parts` array\n       * with one or more metadata objects capturing the source(s) of the\n       * binding.\n       *\n       * @override\n       * @param {Node} node Node to parse\n       * @param {TemplateInfo} templateInfo Template metadata for current template\n       * @param {NodeInfo} nodeInfo Node metadata for current template node\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n\n    }, {\n      key: 'PROPERTY_EFFECT_TYPES',\n      get: function get() {\n        return TYPES;\n      }\n    }], [{\n      key: 'addPropertyEffect',\n      value: function addPropertyEffect(property, type, effect) {\n        this.prototype._addPropertyEffect(property, type, effect);\n      }\n\n      /**\n       * Creates a single-property observer for the given property.\n       *\n       * @param {string} property Property name\n       * @param {string|function(*,*)} method Function or name of observer method to call\n       * @param {boolean=} dynamicFn Whether the method name should be included as\n       *   a dependency to the effect.\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: 'createPropertyObserver',\n      value: function createPropertyObserver(property, method, dynamicFn) {\n        this.prototype._createPropertyObserver(property, method, dynamicFn);\n      }\n\n      /**\n       * Creates a multi-property \"method observer\" based on the provided\n       * expression, which should be a string in the form of a normal JavaScript\n       * function signature: `'methodName(arg1, [..., argn])'`.  Each argument\n       * should correspond to a property or path in the context of this\n       * prototype (or instance), or may be a literal string or number.\n       *\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       * @return {void}\n       *   whether method names should be included as a dependency to the effect.\n       * @protected\n       */\n\n    }, {\n      key: 'createMethodObserver',\n      value: function createMethodObserver(expression, dynamicFn) {\n        this.prototype._createMethodObserver(expression, dynamicFn);\n      }\n\n      /**\n       * Causes the setter for the given property to dispatch `<property>-changed`\n       * events to notify of changes to the property.\n       *\n       * @param {string} property Property name\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: 'createNotifyingProperty',\n      value: function createNotifyingProperty(property) {\n        this.prototype._createNotifyingProperty(property);\n      }\n\n      /**\n       * Creates a read-only accessor for the given property.\n       *\n       * To set the property, use the protected `_setProperty` API.\n       * To create a custom protected setter (e.g. `_setMyProp()` for\n       * property `myProp`), pass `true` for `protectedSetter`.\n       *\n       * Note, if the property will have other property effects, this method\n       * should be called first, before adding other effects.\n       *\n       * @param {string} property Property name\n       * @param {boolean=} protectedSetter Creates a custom protected setter\n       *   when `true`.\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: 'createReadOnlyProperty',\n      value: function createReadOnlyProperty(property, protectedSetter) {\n        this.prototype._createReadOnlyProperty(property, protectedSetter);\n      }\n\n      /**\n       * Causes the setter for the given property to reflect the property value\n       * to a (dash-cased) attribute of the same name.\n       *\n       * @param {string} property Property name\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: 'createReflectedProperty',\n      value: function createReflectedProperty(property) {\n        this.prototype._createReflectedProperty(property);\n      }\n\n      /**\n       * Creates a computed property whose value is set to the result of the\n       * method described by the given `expression` each time one or more\n       * arguments to the method changes.  The expression should be a string\n       * in the form of a normal JavaScript function signature:\n       * `'methodName(arg1, [..., argn])'`\n       *\n       * @param {string} property Name of computed property to set\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n       *   method names should be included as a dependency to the effect.\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: 'createComputedProperty',\n      value: function createComputedProperty(property, expression, dynamicFn) {\n        this.prototype._createComputedProperty(property, expression, dynamicFn);\n      }\n\n      /**\n       * Parses the provided template to ensure binding effects are created\n       * for them, and then ensures property accessors are created for any\n       * dependent properties in the template.  Binding effects for bound\n       * templates are stored in a linked list on the instance so that\n       * templates can be efficiently stamped and unstamped.\n       *\n       * @param {!HTMLTemplateElement} template Template containing binding\n       *   bindings\n       * @return {!TemplateInfo} Template metadata object\n       * @protected\n       */\n\n    }, {\n      key: 'bindTemplate',\n      value: function bindTemplate(template) {\n        return this.prototype._bindTemplate(template);\n      }\n    }, {\n      key: '_addTemplatePropertyEffect',\n      value: function _addTemplatePropertyEffect(templateInfo, prop, effect) {\n        var hostProps = templateInfo.hostProps = templateInfo.hostProps || {};\n        hostProps[prop] = true;\n        var effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};\n        var propEffects = effects[prop] = effects[prop] || [];\n        propEffects.push(effect);\n      }\n    }, {\n      key: '_parseTemplateNode',\n      value: function _parseTemplateNode(node, templateInfo, nodeInfo) {\n        var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNode', this).call(this, node, templateInfo, nodeInfo);\n        if (node.nodeType === Node.TEXT_NODE) {\n          var parts = this._parseBindings(node.textContent, templateInfo);\n          if (parts) {\n            // Initialize the textContent with any literal parts\n            // NOTE: default to a space here so the textNode remains; some browsers\n            // (IE) omit an empty textNode following cloneNode/importNode.\n            node.textContent = literalFromParts(parts) || ' ';\n            addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);\n            noted = true;\n          }\n        }\n        return noted;\n      }\n\n      /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * parsing bindings from attributes.  A `bindings`\n       * array is added to `nodeInfo` and populated with binding metadata\n       * with information capturing the binding target, and a `parts` array\n       * with one or more metadata objects capturing the source(s) of the\n       * binding.\n       *\n       * @override\n       * @param {Element} node Node to parse\n       * @param {TemplateInfo} templateInfo Template metadata for current template\n       * @param {NodeInfo} nodeInfo Node metadata for current template node\n       * @param {string} name Attribute name\n       * @param {string} value Attribute value\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n\n    }, {\n      key: '_parseTemplateNodeAttribute',\n      value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n        var parts = this._parseBindings(value, templateInfo);\n        if (parts) {\n          // Attribute or property\n          var origName = name;\n          var kind = 'property';\n          // The only way we see a capital letter here is if the attr has\n          // a capital letter in it per spec. In this case, to make sure\n          // this binding works, we go ahead and make the binding to the attribute.\n          if (capitalAttributeRegex.test(name)) {\n            kind = 'attribute';\n          } else if (name[name.length - 1] == '$') {\n            name = name.slice(0, -1);\n            kind = 'attribute';\n          }\n          // Initialize attribute bindings with any literal parts\n          var literal = literalFromParts(parts);\n          if (literal && kind == 'attribute') {\n            node.setAttribute(name, literal);\n          }\n          // Clear attribute before removing, since IE won't allow removing\n          // `value` attribute if it previously had a value (can't\n          // unconditionally set '' before removing since attributes with `$`\n          // can't be set using setAttribute)\n          if (node.localName === 'input' && origName === 'value') {\n            node.setAttribute(origName, '');\n          }\n          // Remove annotation\n          node.removeAttribute(origName);\n          // Case hackery: attributes are lower-case, but bind targets\n          // (properties) are case sensitive. Gambit is to map dash-case to\n          // camel-case: `foo-bar` becomes `fooBar`.\n          // Attribute bindings are excepted.\n          if (kind === 'property') {\n            name = (0, _caseMap.dashToCamelCase)(name);\n          }\n          addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);\n          return true;\n        } else {\n          return _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNodeAttribute', this).call(this, node, templateInfo, nodeInfo, name, value);\n        }\n      }\n\n      /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * binding the properties that a nested template depends on to the template\n       * as `_host_<property>`.\n       *\n       * @override\n       * @param {Node} node Node to parse\n       * @param {TemplateInfo} templateInfo Template metadata for current template\n       * @param {NodeInfo} nodeInfo Node metadata for current template node\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n\n    }, {\n      key: '_parseTemplateNestedTemplate',\n      value: function _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {\n        var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNestedTemplate', this).call(this, node, templateInfo, nodeInfo);\n        // Merge host props into outer template and add bindings\n        var hostProps = nodeInfo.templateInfo.hostProps;\n        var mode = '{';\n        for (var source in hostProps) {\n          var parts = [{ mode: mode, source: source, dependencies: [source] }];\n          addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);\n        }\n        return noted;\n      }\n\n      /**\n       * Called to parse text in a template (either attribute values or\n       * textContent) into binding metadata.\n       *\n       * Any overrides of this method should return an array of binding part\n       * metadata  representing one or more bindings found in the provided text\n       * and any \"literal\" text in between.  Any non-literal parts will be passed\n       * to `_evaluateBinding` when any dependencies change.  The only required\n       * fields of each \"part\" in the returned array are as follows:\n       *\n       * - `dependencies` - Array containing trigger metadata for each property\n       *   that should trigger the binding to update\n       * - `literal` - String containing text if the part represents a literal;\n       *   in this case no `dependencies` are needed\n       *\n       * Additional metadata for use by `_evaluateBinding` may be provided in\n       * each part object as needed.\n       *\n       * The default implementation handles the following types of bindings\n       * (one or more may be intermixed with literal strings):\n       * - Property binding: `[[prop]]`\n       * - Path binding: `[[object.prop]]`\n       * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`\n       * - Two-way property or path bindings (supports negation):\n       *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`\n       * - Inline computed method (supports negation):\n       *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`\n       *\n       * @param {string} text Text to parse from attribute or textContent\n       * @param {Object} templateInfo Current template metadata\n       * @return {Array<!BindingPart>} Array of binding part metadata\n       * @protected\n       */\n\n    }, {\n      key: '_parseBindings',\n      value: function _parseBindings(text, templateInfo) {\n        var parts = [];\n        var lastIndex = 0;\n        var m = void 0;\n        // Example: \"literal1{{prop}}literal2[[!compute(foo,bar)]]final\"\n        // Regex matches:\n        //        Iteration 1:  Iteration 2:\n        // m[1]: '{{'          '[['\n        // m[2]: ''            '!'\n        // m[3]: 'prop'        'compute(foo,bar)'\n        while ((m = bindingRegex.exec(text)) !== null) {\n          // Add literal part\n          if (m.index > lastIndex) {\n            parts.push({ literal: text.slice(lastIndex, m.index) });\n          }\n          // Add binding part\n          var mode = m[1][0];\n          var negate = Boolean(m[2]);\n          var source = m[3].trim();\n          var customEvent = false,\n              notifyEvent = '',\n              colon = -1;\n          if (mode == '{' && (colon = source.indexOf('::')) > 0) {\n            notifyEvent = source.substring(colon + 2);\n            source = source.substring(0, colon);\n            customEvent = true;\n          }\n          var signature = parseMethod(source);\n          var dependencies = [];\n          if (signature) {\n            // Inline computed function\n            var args = signature.args,\n                methodName = signature.methodName;\n\n            for (var i = 0; i < args.length; i++) {\n              var arg = args[i];\n              if (!arg.literal) {\n                dependencies.push(arg);\n              }\n            }\n            var dynamicFns = templateInfo.dynamicFns;\n            if (dynamicFns && dynamicFns[methodName] || signature.static) {\n              dependencies.push(methodName);\n              signature.dynamicFn = true;\n            }\n          } else {\n            // Property or path\n            dependencies.push(source);\n          }\n          parts.push({\n            source: source, mode: mode, negate: negate, customEvent: customEvent, signature: signature, dependencies: dependencies,\n            event: notifyEvent\n          });\n          lastIndex = bindingRegex.lastIndex;\n        }\n        // Add a final literal part\n        if (lastIndex && lastIndex < text.length) {\n          var literal = text.substring(lastIndex);\n          if (literal) {\n            parts.push({\n              literal: literal\n            });\n          }\n        }\n        if (parts.length) {\n          return parts;\n        } else {\n          return null;\n        }\n      }\n\n      /**\n       * Called to evaluate a previously parsed binding part based on a set of\n       * one or more changed dependencies.\n       *\n       * @param {this} inst Element that should be used as scope for\n       *   binding dependencies\n       * @param {BindingPart} part Binding part metadata\n       * @param {string} path Property/path that triggered this effect\n       * @param {Object} props Bag of current property changes\n       * @param {Object} oldProps Bag of previous values for changed properties\n       * @param {boolean} hasPaths True with `props` contains one or more paths\n       * @return {*} Value the binding part evaluated to\n       * @protected\n       */\n\n    }, {\n      key: '_evaluateBinding',\n      value: function _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {\n        var value = void 0;\n        if (part.signature) {\n          value = runMethodEffect(inst, path, props, oldProps, part.signature);\n        } else if (path != part.source) {\n          value = (0, _path.get)(inst, part.source);\n        } else {\n          if (hasPaths && (0, _path.isPath)(path)) {\n            value = (0, _path.get)(inst, path);\n          } else {\n            value = inst.__data[path];\n          }\n        }\n        if (part.negate) {\n          value = !value;\n        }\n        return value;\n      }\n    }]);\n\n    return PropertyEffects;\n  }(propertyEffectsBase);\n\n  // make a typing for closure :P\n\n\n  PropertyEffectsType = PropertyEffects;\n\n  return PropertyEffects;\n});\n\n/**\n * Helper api for enqueuing client dom created by a host element.\n *\n * By default elements are flushed via `_flushProperties` when\n * `connectedCallback` is called. Elements attach their client dom to\n * themselves at `ready` time which results from this first flush.\n * This provides an ordering guarantee that the client dom an element\n * creates is flushed before the element itself (i.e. client `ready`\n * fires before host `ready`).\n *\n * However, if `_flushProperties` is called *before* an element is connected,\n * as for example `Templatize` does, this ordering guarantee cannot be\n * satisfied because no elements are connected. (Note: Bound elements that\n * receive data do become enqueued clients and are properly ordered but\n * unbound elements are not.)\n *\n * To maintain the desired \"client before host\" ordering guarantee for this\n * case we rely on the \"host stack. Client nodes registers themselves with\n * the creating host element when created. This ensures that all client dom\n * is readied in the proper order, maintaining the desired guarantee.\n *\n * @private\n */\nvar hostStack = {\n\n  stack: [],\n\n  /**\n   * @param {*} inst Instance to add to hostStack\n   * @return {void}\n   * @this {hostStack}\n   */\n  registerHost: function registerHost(inst) {\n    if (this.stack.length) {\n      var host = this.stack[this.stack.length - 1];\n      host._enqueueClient(inst);\n    }\n  },\n\n\n  /**\n   * @param {*} inst Instance to begin hosting\n   * @return {void}\n   * @this {hostStack}\n   */\n  beginHosting: function beginHosting(inst) {\n    this.stack.push(inst);\n  },\n\n\n  /**\n   * @param {*} inst Instance to end hosting\n   * @return {void}\n   * @this {hostStack}\n   */\n  endHosting: function endHosting(inst) {\n    var stackLen = this.stack.length;\n    if (stackLen && this.stack[stackLen - 1] == inst) {\n      this.stack.pop();\n    }\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/mixins/property-effects.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/template-stamp.js":
/*!********************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/template-stamp.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TemplateStamp = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n\nvar _mixin = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@polymer/polymer/lib/utils/mixin.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// 1.x backwards-compatible auto-wrapper for template type extensions\n// This is a clear layering violation and gives favored-nation status to\n// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep\n// a.) to ease 1.x backwards-compatibility due to loss of `is`, and\n// b.) to maintain if/repeat capability in parser-constrained elements\n//     (e.g. table, select) in lieu of native CE type extensions without\n//     massive new invention in this space (e.g. directive system)\nvar templateExtensions = {\n  'dom-if': true,\n  'dom-repeat': true\n};\nfunction wrapTemplateExtension(node) {\n  var is = node.getAttribute('is');\n  if (is && templateExtensions[is]) {\n    var t = node;\n    t.removeAttribute('is');\n    node = t.ownerDocument.createElement(is);\n    t.parentNode.replaceChild(node, t);\n    node.appendChild(t);\n    while (t.attributes.length) {\n      node.setAttribute(t.attributes[0].name, t.attributes[0].value);\n      t.removeAttribute(t.attributes[0].name);\n    }\n  }\n  return node;\n}\n\nfunction findTemplateNode(root, nodeInfo) {\n  // recursively ascend tree until we hit root\n  var parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);\n  // unwind the stack, returning the indexed node at each level\n  if (parent) {\n    // note: marginally faster than indexing via childNodes\n    // (http://jsperf.com/childnodes-lookup)\n    for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {\n      if (nodeInfo.parentIndex === i++) {\n        return n;\n      }\n    }\n  } else {\n    return root;\n  }\n}\n\n// construct `$` map (from id annotations)\nfunction applyIdToMap(inst, map, node, nodeInfo) {\n  if (nodeInfo.id) {\n    map[nodeInfo.id] = node;\n  }\n}\n\n// install event listeners (from event annotations)\nfunction applyEventListener(inst, node, nodeInfo) {\n  if (nodeInfo.events && nodeInfo.events.length) {\n    for (var j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {\n      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);\n    }\n  }\n}\n\n// push configuration references at configure time\nfunction applyTemplateContent(inst, node, nodeInfo) {\n  if (nodeInfo.templateInfo) {\n    node._templateInfo = nodeInfo.templateInfo;\n  }\n}\n\nfunction createNodeEventHandler(context, eventName, methodName) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  context = context._methodHost || context;\n  var handler = function handler(e) {\n    if (context[methodName]) {\n      context[methodName](e, e.detail);\n    } else {\n      console.warn('listener method `' + methodName + '` not defined');\n    }\n  };\n  return handler;\n}\n\nvar TemplateStamp = exports.TemplateStamp = (0, _mixin.dedupingMixin)(function (superClass) {\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_TemplateStamp}\n   */\n  var TemplateStamp = function (_superClass) {\n    _inherits(TemplateStamp, _superClass);\n\n    function TemplateStamp() {\n      _classCallCheck(this, TemplateStamp);\n\n      return _possibleConstructorReturn(this, (TemplateStamp.__proto__ || Object.getPrototypeOf(TemplateStamp)).apply(this, arguments));\n    }\n\n    _createClass(TemplateStamp, [{\n      key: '_stampTemplate',\n\n\n      /**\n       * Clones the provided template content and returns a document fragment\n       * containing the cloned dom.\n       *\n       * The template is parsed (once and memoized) using this library's\n       * template parsing features, and provides the following value-added\n       * features:\n       * * Adds declarative event listeners for `on-event=\"handler\"` attributes\n       * * Generates an \"id map\" for all nodes with id's under `$` on returned\n       *   document fragment\n       * * Passes template info including `content` back to templates as\n       *   `_templateInfo` (a performance optimization to avoid deep template\n       *   cloning)\n       *\n       * Note that the memoized template parsing process is destructive to the\n       * template: attributes for bindings and declarative event listeners are\n       * removed after being noted in notes, and any nested `<template>.content`\n       * is removed and stored in notes as well.\n       *\n       * @param {!HTMLTemplateElement} template Template to stamp\n       * @return {!StampedTemplate} Cloned template content\n       */\n      value: function _stampTemplate(template) {\n        // Polyfill support: bootstrap the template if it has not already been\n        if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n          HTMLTemplateElement.decorate(template);\n        }\n        var templateInfo = this.constructor._parseTemplate(template);\n        var nodeInfo = templateInfo.nodeInfoList;\n        var content = templateInfo.content || template.content;\n        var dom = /** @type {DocumentFragment} */document.importNode(content, true);\n        // NOTE: ShadyDom optimization indicating there is an insertion point\n        dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;\n        var nodes = dom.nodeList = new Array(nodeInfo.length);\n        dom.$ = {};\n        for (var i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {\n          var node = nodes[i] = findTemplateNode(dom, info);\n          applyIdToMap(this, dom.$, node, info);\n          applyTemplateContent(this, node, info);\n          applyEventListener(this, node, info);\n        }\n        dom = /** @type {!StampedTemplate} */dom; // eslint-disable-line no-self-assign\n        return dom;\n      }\n\n      /**\n       * Adds an event listener by method name for the event provided.\n       *\n       * This method generates a handler function that looks up the method\n       * name at handling time.\n       *\n       * @param {!Node} node Node to add listener on\n       * @param {string} eventName Name of event\n       * @param {string} methodName Name of method\n       * @param {*=} context Context the method will be called on (defaults\n       *   to `node`)\n       * @return {Function} Generated handler function\n       */\n\n    }, {\n      key: '_addMethodEventListenerToNode',\n      value: function _addMethodEventListenerToNode(node, eventName, methodName, context) {\n        context = context || node;\n        var handler = createNodeEventHandler(context, eventName, methodName);\n        this._addEventListenerToNode(node, eventName, handler);\n        return handler;\n      }\n\n      /**\n       * Override point for adding custom or simulated event handling.\n       *\n       * @param {!Node} node Node to add event listener to\n       * @param {string} eventName Name of event\n       * @param {function(!Event):void} handler Listener function to add\n       * @return {void}\n       */\n\n    }, {\n      key: '_addEventListenerToNode',\n      value: function _addEventListenerToNode(node, eventName, handler) {\n        node.addEventListener(eventName, handler);\n      }\n\n      /**\n       * Override point for adding custom or simulated event handling.\n       *\n       * @param {Node} node Node to remove event listener from\n       * @param {string} eventName Name of event\n       * @param {function(!Event):void} handler Listener function to remove\n       * @return {void}\n       */\n\n    }, {\n      key: '_removeEventListenerFromNode',\n      value: function _removeEventListenerFromNode(node, eventName, handler) {\n        node.removeEventListener(eventName, handler);\n      }\n    }], [{\n      key: '_parseTemplate',\n\n\n      /**\n       * Scans a template to produce template metadata.\n       *\n       * Template-specific metadata are stored in the object returned, and node-\n       * specific metadata are stored in objects in its flattened `nodeInfoList`\n       * array.  Only nodes in the template that were parsed as nodes of\n       * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object\n       * contains an `index` (`childNodes` index in parent) and optionally\n       * `parent`, which points to node info of its parent (including its index).\n       *\n       * The template metadata object returned from this method has the following\n       * structure (many fields optional):\n       *\n       * ```js\n       *   {\n       *     // Flattened list of node metadata (for nodes that generated metadata)\n       *     nodeInfoList: [\n       *       {\n       *         // `id` attribute for any nodes with id's for generating `$` map\n       *         id: {string},\n       *         // `on-event=\"handler\"` metadata\n       *         events: [\n       *           {\n       *             name: {string},   // event name\n       *             value: {string},  // handler method name\n       *           }, ...\n       *         ],\n       *         // Notes when the template contained a `<slot>` for shady DOM\n       *         // optimization purposes\n       *         hasInsertionPoint: {boolean},\n       *         // For nested `<template>`` nodes, nested template metadata\n       *         templateInfo: {object}, // nested template metadata\n       *         // Metadata to allow efficient retrieval of instanced node\n       *         // corresponding to this metadata\n       *         parentInfo: {number},   // reference to parent nodeInfo>\n       *         parentIndex: {number},  // index in parent's `childNodes` collection\n       *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`\n       *       },\n       *       ...\n       *     ],\n       *     // When true, the template had the `strip-whitespace` attribute\n       *     // or was nested in a template with that setting\n       *     stripWhitespace: {boolean},\n       *     // For nested templates, nested template content is moved into\n       *     // a document fragment stored here; this is an optimization to\n       *     // avoid the cost of nested template cloning\n       *     content: {DocumentFragment}\n       *   }\n       * ```\n       *\n       * This method kicks off a recursive treewalk as follows:\n       *\n       * ```\n       *    _parseTemplate <---------------------+\n       *      _parseTemplateContent              |\n       *        _parseTemplateNode  <------------|--+\n       *          _parseTemplateNestedTemplate --+  |\n       *          _parseTemplateChildNodes ---------+\n       *          _parseTemplateNodeAttributes\n       *            _parseTemplateNodeAttribute\n       *\n       * ```\n       *\n       * These methods may be overridden to add custom metadata about templates\n       * to either `templateInfo` or `nodeInfo`.\n       *\n       * Note that this method may be destructive to the template, in that\n       * e.g. event annotations may be removed after being noted in the\n       * template metadata.\n       *\n       * @param {!HTMLTemplateElement} template Template to parse\n       * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer\n       *   template, for parsing nested templates\n       * @return {!TemplateInfo} Parsed template metadata\n       */\n      value: function _parseTemplate(template, outerTemplateInfo) {\n        // since a template may be re-used, memo-ize metadata\n        if (!template._templateInfo) {\n          var templateInfo = template._templateInfo = {};\n          templateInfo.nodeInfoList = [];\n          templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace');\n          this._parseTemplateContent(template, templateInfo, { parent: null });\n        }\n        return template._templateInfo;\n      }\n    }, {\n      key: '_parseTemplateContent',\n      value: function _parseTemplateContent(template, templateInfo, nodeInfo) {\n        return this._parseTemplateNode(template.content, templateInfo, nodeInfo);\n      }\n\n      /**\n       * Parses template node and adds template and node metadata based on\n       * the current node, and its `childNodes` and `attributes`.\n       *\n       * This method may be overridden to add custom node or template specific\n       * metadata based on this node.\n       *\n       * @param {Node} node Node to parse\n       * @param {!TemplateInfo} templateInfo Template metadata for current template\n       * @param {!NodeInfo} nodeInfo Node metadata for current template.\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n\n    }, {\n      key: '_parseTemplateNode',\n      value: function _parseTemplateNode(node, templateInfo, nodeInfo) {\n        var noted = void 0;\n        var element = /** @type {Element} */node;\n        if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {\n          noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;\n        } else if (element.localName === 'slot') {\n          // For ShadyDom optimization, indicating there is an insertion point\n          templateInfo.hasInsertionPoint = true;\n        }\n        if (element.firstChild) {\n          noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;\n        }\n        if (element.hasAttributes && element.hasAttributes()) {\n          noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;\n        }\n        return noted;\n      }\n\n      /**\n       * Parses template child nodes for the given root node.\n       *\n       * This method also wraps whitelisted legacy template extensions\n       * (`is=\"dom-if\"` and `is=\"dom-repeat\"`) with their equivalent element\n       * wrappers, collapses text nodes, and strips whitespace from the template\n       * if the `templateInfo.stripWhitespace` setting was provided.\n       *\n       * @param {Node} root Root node whose `childNodes` will be parsed\n       * @param {!TemplateInfo} templateInfo Template metadata for current template\n       * @param {!NodeInfo} nodeInfo Node metadata for current template.\n       * @return {void}\n       */\n\n    }, {\n      key: '_parseTemplateChildNodes',\n      value: function _parseTemplateChildNodes(root, templateInfo, nodeInfo) {\n        if (root.localName === 'script' || root.localName === 'style') {\n          return;\n        }\n        for (var node = root.firstChild, parentIndex = 0, next; node; node = next) {\n          // Wrap templates\n          if (node.localName == 'template') {\n            node = wrapTemplateExtension(node);\n          }\n          // collapse adjacent textNodes: fixes an IE issue that can cause\n          // text nodes to be inexplicably split =(\n          // note that root.normalize() should work but does not so we do this\n          // manually.\n          next = node.nextSibling;\n          if (node.nodeType === Node.TEXT_NODE) {\n            var /** Node */n = next;\n            while (n && n.nodeType === Node.TEXT_NODE) {\n              node.textContent += n.textContent;\n              next = n.nextSibling;\n              root.removeChild(n);\n              n = next;\n            }\n            // optionally strip whitespace\n            if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {\n              root.removeChild(node);\n              continue;\n            }\n          }\n          var childInfo = { parentIndex: parentIndex, parentInfo: nodeInfo };\n          if (this._parseTemplateNode(node, templateInfo, childInfo)) {\n            childInfo.infoIndex = templateInfo.nodeInfoList.push( /** @type {!NodeInfo} */childInfo) - 1;\n          }\n          // Increment if not removed\n          if (node.parentNode) {\n            parentIndex++;\n          }\n        }\n      }\n\n      /**\n       * Parses template content for the given nested `<template>`.\n       *\n       * Nested template info is stored as `templateInfo` in the current node's\n       * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.\n       * It will then be the responsibility of the host to set it back to the\n       * template and for users stamping nested templates to use the\n       * `_contentForTemplate` method to retrieve the content for this template\n       * (an optimization to avoid the cost of cloning nested template content).\n       *\n       * @param {HTMLTemplateElement} node Node to parse (a <template>)\n       * @param {TemplateInfo} outerTemplateInfo Template metadata for current template\n       *   that includes the template `node`\n       * @param {!NodeInfo} nodeInfo Node metadata for current template.\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n\n    }, {\n      key: '_parseTemplateNestedTemplate',\n      value: function _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {\n        var templateInfo = this._parseTemplate(node, outerTemplateInfo);\n        var content = templateInfo.content = node.content.ownerDocument.createDocumentFragment();\n        content.appendChild(node.content);\n        nodeInfo.templateInfo = templateInfo;\n        return true;\n      }\n\n      /**\n       * Parses template node attributes and adds node metadata to `nodeInfo`\n       * for nodes of interest.\n       *\n       * @param {Element} node Node to parse\n       * @param {TemplateInfo} templateInfo Template metadata for current template\n       * @param {NodeInfo} nodeInfo Node metadata for current template.\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n\n    }, {\n      key: '_parseTemplateNodeAttributes',\n      value: function _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {\n        // Make copy of original attribute list, since the order may change\n        // as attributes are added and removed\n        var noted = false;\n        var attrs = Array.from(node.attributes);\n        for (var i = attrs.length - 1, a; a = attrs[i]; i--) {\n          noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;\n        }\n        return noted;\n      }\n\n      /**\n       * Parses a single template node attribute and adds node metadata to\n       * `nodeInfo` for attributes of interest.\n       *\n       * This implementation adds metadata for `on-event=\"handler\"` attributes\n       * and `id` attributes.\n       *\n       * @param {Element} node Node to parse\n       * @param {!TemplateInfo} templateInfo Template metadata for current template\n       * @param {!NodeInfo} nodeInfo Node metadata for current template.\n       * @param {string} name Attribute name\n       * @param {string} value Attribute value\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n\n    }, {\n      key: '_parseTemplateNodeAttribute',\n      value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n        // events (on-*)\n        if (name.slice(0, 3) === 'on-') {\n          node.removeAttribute(name);\n          nodeInfo.events = nodeInfo.events || [];\n          nodeInfo.events.push({\n            name: name.slice(3),\n            value: value\n          });\n          return true;\n        }\n        // static id\n        else if (name === 'id') {\n            nodeInfo.id = value;\n            return true;\n          }\n        return false;\n      }\n\n      /**\n       * Returns the `content` document fragment for a given template.\n       *\n       * For nested templates, Polymer performs an optimization to cache nested\n       * template content to avoid the cost of cloning deeply nested templates.\n       * This method retrieves the cached content for a given template.\n       *\n       * @param {HTMLTemplateElement} template Template to retrieve `content` for\n       * @return {DocumentFragment} Content fragment\n       */\n\n    }, {\n      key: '_contentForTemplate',\n      value: function _contentForTemplate(template) {\n        var templateInfo = /** @type {HTMLTemplateElementWithInfo} */template._templateInfo;\n        return templateInfo && templateInfo.content || template.content;\n      }\n    }]);\n\n    return TemplateStamp;\n  }(superClass);\n\n  return TemplateStamp;\n});\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/mixins/template-stamp.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/async.js":
/*!**********************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/async.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.microTask = exports.idlePeriod = exports.animationFrame = exports.timeOut = undefined;\n\n__webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n\n// Microtask implemented using Mutation Observer\nvar microtaskCurrHandle = 0;\nvar microtaskLastHandle = 0;\nvar microtaskCallbacks = [];\nvar microtaskNodeContent = 0;\nvar microtaskNode = document.createTextNode('');\nnew window.MutationObserver(microtaskFlush).observe(microtaskNode, { characterData: true });\n\nfunction microtaskFlush() {\n  var len = microtaskCallbacks.length;\n  for (var i = 0; i < len; i++) {\n    var cb = microtaskCallbacks[i];\n    if (cb) {\n      try {\n        cb();\n      } catch (e) {\n        setTimeout(function () {\n          throw e;\n        });\n      }\n    }\n  }\n  microtaskCallbacks.splice(0, len);\n  microtaskLastHandle += len;\n}\n\nvar timeOut = exports.timeOut = {\n  /**\n   * Returns a sub-module with the async interface providing the provided\n   * delay.\n   *\n   * @memberof Polymer.Async.timeOut\n   * @param {number=} delay Time to wait before calling callbacks in ms\n   * @return {!AsyncInterface} An async timeout interface\n   */\n  after: function after(delay) {\n    return {\n      run: function run(fn) {\n        return window.setTimeout(fn, delay);\n      },\n      cancel: function cancel(handle) {\n        window.clearTimeout(handle);\n      }\n    };\n  },\n\n  /**\n   * Enqueues a function called in the next task.\n   *\n   * @memberof Polymer.Async.timeOut\n   * @param {!Function} fn Callback to run\n   * @param {number=} delay Delay in milliseconds\n   * @return {number} Handle used for canceling task\n   */\n  run: function run(fn, delay) {\n    return window.setTimeout(fn, delay);\n  },\n\n  /**\n   * Cancels a previously enqueued `timeOut` callback.\n   *\n   * @memberof Polymer.Async.timeOut\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel: function cancel(handle) {\n    window.clearTimeout(handle);\n  }\n};\n\nvar animationFrame = exports.animationFrame = {\n  /**\n   * Enqueues a function called at `requestAnimationFrame` timing.\n   *\n   * @memberof Polymer.Async.animationFrame\n   * @param {function(number):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run: function run(fn) {\n    return window.requestAnimationFrame(fn);\n  },\n\n  /**\n   * Cancels a previously enqueued `animationFrame` callback.\n   *\n   * @memberof Polymer.Async.animationFrame\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel: function cancel(handle) {\n    window.cancelAnimationFrame(handle);\n  }\n};\n\nvar idlePeriod = exports.idlePeriod = {\n  /**\n   * Enqueues a function called at `requestIdleCallback` timing.\n   *\n   * @memberof Polymer.Async.idlePeriod\n   * @param {function(!IdleDeadline):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run: function run(fn) {\n    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);\n  },\n\n  /**\n   * Cancels a previously enqueued `idlePeriod` callback.\n   *\n   * @memberof Polymer.Async.idlePeriod\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel: function cancel(handle) {\n    window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);\n  }\n};\n\nvar microTask = exports.microTask = {\n\n  /**\n   * Enqueues a function called at microtask timing.\n   *\n   * @memberof Polymer.Async.microTask\n   * @param {!Function=} callback Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run: function run(callback) {\n    microtaskNode.textContent = microtaskNodeContent++;\n    microtaskCallbacks.push(callback);\n    return microtaskCurrHandle++;\n  },\n\n\n  /**\n   * Cancels a previously enqueued `microTask` callback.\n   *\n   * @memberof Polymer.Async.microTask\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel: function cancel(handle) {\n    var idx = handle - microtaskLastHandle;\n    if (idx >= 0) {\n      if (!microtaskCallbacks[idx]) {\n        throw new Error('invalid async handle: ' + handle);\n      }\n      microtaskCallbacks[idx] = null;\n    }\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/utils/async.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/boot.js":
/*!*********************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/boot.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nwindow.JSCompiler_renameProperty = function (prop, obj) {\n  return prop;\n};\n\n/** @namespace Polymer */\nvar __PolymerBootstrap = void 0;\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/utils/boot.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/case-map.js":
/*!*************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/case-map.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dashToCamelCase = dashToCamelCase;\nexports.camelToDashCase = camelToDashCase;\n\n__webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n\nvar caseMap = {};\nvar DASH_TO_CAMEL = /-[a-z]/g;\nvar CAMEL_TO_DASH = /([A-Z])/g;\n\nfunction dashToCamelCase(dash) {\n  return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, function (m) {\n    return m[1].toUpperCase();\n  }));\n}\n\nfunction camelToDashCase(camel) {\n  return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());\n}\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/utils/case-map.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/debounce.js":
/*!*************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/debounce.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Debouncer = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n\n__webpack_require__(/*! ./mixin.js */ \"./node_modules/@polymer/polymer/lib/utils/mixin.js\");\n\n__webpack_require__(/*! ./async.js */ \"./node_modules/@polymer/polymer/lib/utils/async.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @summary Collapse multiple callbacks into one invocation after a timer.\n * @memberof Polymer\n */\nvar Debouncer = function () {\n  function Debouncer() {\n    _classCallCheck(this, Debouncer);\n\n    this._asyncModule = null;\n    this._callback = null;\n    this._timer = null;\n  }\n  /**\n   * Sets the scheduler; that is, a module with the Async interface,\n   * a callback and optional arguments to be passed to the run function\n   * from the async module.\n   *\n   * @param {!AsyncInterface} asyncModule Object with Async interface.\n   * @param {function()} callback Callback to run.\n   * @return {void}\n   */\n\n\n  _createClass(Debouncer, [{\n    key: 'setConfig',\n    value: function setConfig(asyncModule, callback) {\n      var _this = this;\n\n      this._asyncModule = asyncModule;\n      this._callback = callback;\n      this._timer = this._asyncModule.run(function () {\n        _this._timer = null;\n        _this._callback();\n      });\n    }\n    /**\n     * Cancels an active debouncer and returns a reference to itself.\n     *\n     * @return {void}\n     */\n\n  }, {\n    key: 'cancel',\n    value: function cancel() {\n      if (this.isActive()) {\n        this._asyncModule.cancel(this._timer);\n        this._timer = null;\n      }\n    }\n    /**\n     * Flushes an active debouncer and returns a reference to itself.\n     *\n     * @return {void}\n     */\n\n  }, {\n    key: 'flush',\n    value: function flush() {\n      if (this.isActive()) {\n        this.cancel();\n        this._callback();\n      }\n    }\n    /**\n     * Returns true if the debouncer is active.\n     *\n     * @return {boolean} True if active.\n     */\n\n  }, {\n    key: 'isActive',\n    value: function isActive() {\n      return this._timer != null;\n    }\n    /**\n     * Creates a debouncer if no debouncer is passed as a parameter\n     * or it cancels an active debouncer otherwise. The following\n     * example shows how a debouncer can be called multiple times within a\n     * microtask and \"debounced\" such that the provided callback function is\n     * called once. Add this method to a custom element:\n     *\n     * _debounceWork() {\n     *   this._debounceJob = Polymer.Debouncer.debounce(this._debounceJob,\n     *       Polymer.Async.microTask, () => {\n     *     this._doWork();\n     *   });\n     * }\n     *\n     * If the `_debounceWork` method is called multiple times within the same\n     * microtask, the `_doWork` function will be called only once at the next\n     * microtask checkpoint.\n     *\n     * Note: In testing it is often convenient to avoid asynchrony. To accomplish\n     * this with a debouncer, you can use `Polymer.enqueueDebouncer` and\n     * `Polymer.flush`. For example, extend the above example by adding\n     * `Polymer.enqueueDebouncer(this._debounceJob)` at the end of the\n     * `_debounceWork` method. Then in a test, call `Polymer.flush` to ensure\n     * the debouncer has completed.\n     *\n     * @param {Debouncer?} debouncer Debouncer object.\n     * @param {!AsyncInterface} asyncModule Object with Async interface\n     * @param {function()} callback Callback to run.\n     * @return {!Debouncer} Returns a debouncer object.\n     */\n\n  }], [{\n    key: 'debounce',\n    value: function debounce(debouncer, asyncModule, callback) {\n      if (debouncer instanceof Debouncer) {\n        debouncer.cancel();\n      } else {\n        debouncer = new Debouncer();\n      }\n      debouncer.setConfig(asyncModule, callback);\n      return debouncer;\n    }\n  }]);\n\n  return Debouncer;\n}();\n\nexports.Debouncer = Debouncer;\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/utils/debounce.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/flush.js":
/*!**********************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/flush.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.flush = exports.enqueueDebouncer = undefined;\n\n__webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n\nvar debouncerQueue = [];\n\nvar enqueueDebouncer = exports.enqueueDebouncer = function enqueueDebouncer(debouncer) {\n  debouncerQueue.push(debouncer);\n};\n\nfunction flushDebouncers() {\n  var didFlush = Boolean(debouncerQueue.length);\n  while (debouncerQueue.length) {\n    try {\n      debouncerQueue.shift().flush();\n    } catch (e) {\n      setTimeout(function () {\n        throw e;\n      });\n    }\n  }\n  return didFlush;\n}\n\nvar flush = exports.flush = function flush() {\n  var shadyDOM = void 0,\n      debouncers = void 0;\n  do {\n    shadyDOM = window.ShadyDOM && ShadyDOM.flush();\n    if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {\n      window.ShadyCSS.ScopingShim.flush();\n    }\n    debouncers = flushDebouncers();\n  } while (shadyDOM || debouncers);\n};\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/utils/flush.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/html-tag.js":
/*!*************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/html-tag.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.htmlLiteral = exports.html = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Class representing a static string value which can be used to filter\n * strings by asseting that they have been created via this class. The\n * `value` property returns the string passed to the constructor.\n */\nvar LiteralString = function () {\n  function LiteralString(string) {\n    _classCallCheck(this, LiteralString);\n\n    /** @type {string} */\n    this.value = string.toString();\n  }\n  /**\n   * @return {string} LiteralString string value\n   */\n\n\n  _createClass(LiteralString, [{\n    key: 'toString',\n    value: function toString() {\n      return this.value;\n    }\n  }]);\n\n  return LiteralString;\n}();\n\n/**\n * @param {*} value Object to stringify into HTML\n * @return {string} HTML stringified form of `obj`\n */\n\n\nfunction literalValue(value) {\n  if (value instanceof LiteralString) {\n    return (/** @type {!LiteralString} */value.value\n    );\n  } else {\n    throw new Error('non-literal value passed to Polymer.htmlLiteral: ' + value);\n  }\n}\n\n/**\n * @param {*} value Object to stringify into HTML\n * @return {string} HTML stringified form of `obj`\n */\nfunction htmlValue(value) {\n  if (value instanceof HTMLTemplateElement) {\n    return (/** @type {!HTMLTemplateElement } */value.innerHTML\n    );\n  } else if (value instanceof LiteralString) {\n    return literalValue(value);\n  } else {\n    throw new Error('non-template value passed to Polymer.html: ' + value);\n  }\n}\n\nvar html = exports.html = function html(strings) {\n  var template = /** @type {!HTMLTemplateElement} */document.createElement('template');\n\n  for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    values[_key - 1] = arguments[_key];\n  }\n\n  template.innerHTML = values.reduce(function (acc, v, idx) {\n    return acc + htmlValue(v) + strings[idx + 1];\n  }, strings[0]);\n  return template;\n};\n\nvar htmlLiteral = exports.htmlLiteral = function htmlLiteral(strings) {\n  for (var _len2 = arguments.length, values = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    values[_key2 - 1] = arguments[_key2];\n  }\n\n  return new LiteralString(values.reduce(function (acc, v, idx) {\n    return acc + literalValue(v) + strings[idx + 1];\n  }, strings[0]));\n};\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/utils/html-tag.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/mixin.js":
/*!**********************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/mixin.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dedupingMixin = undefined;\n\n__webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n\n// unique global id for deduping mixins.\nvar dedupeId = 0;\n\n/**\n * @constructor\n * @extends {Function}\n */\nfunction MixinFunction() {}\n/** @type {(WeakMap | undefined)} */\nMixinFunction.prototype.__mixinApplications;\n/** @type {(Object | undefined)} */\nMixinFunction.prototype.__mixinSet;\n\nvar dedupingMixin = exports.dedupingMixin = function dedupingMixin(mixin) {\n  var mixinApplications = /** @type {!MixinFunction} */mixin.__mixinApplications;\n  if (!mixinApplications) {\n    mixinApplications = new WeakMap();\n    /** @type {!MixinFunction} */mixin.__mixinApplications = mixinApplications;\n  }\n  // maintain a unique id for each mixin\n  var mixinDedupeId = dedupeId++;\n  function dedupingMixin(base) {\n    var baseSet = /** @type {!MixinFunction} */base.__mixinSet;\n    if (baseSet && baseSet[mixinDedupeId]) {\n      return base;\n    }\n    var map = mixinApplications;\n    var extended = map.get(base);\n    if (!extended) {\n      extended = /** @type {!Function} */mixin(base);\n      map.set(base, extended);\n    }\n    // copy inherited mixin set from the extended class, or the base class\n    // NOTE: we avoid use of Set here because some browser (IE11)\n    // cannot extend a base Set via the constructor.\n    var mixinSet = Object.create( /** @type {!MixinFunction} */extended.__mixinSet || baseSet || null);\n    mixinSet[mixinDedupeId] = true;\n    /** @type {!MixinFunction} */extended.__mixinSet = mixinSet;\n    return extended;\n  }\n\n  return (/** @type {T} */dedupingMixin\n  );\n};\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/utils/mixin.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/path.js":
/*!*********************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/path.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isDeep = undefined;\nexports.isPath = isPath;\nexports.root = root;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\nexports.translate = translate;\nexports.matches = matches;\nexports.normalize = normalize;\nexports.split = split;\nexports.get = get;\nexports.set = set;\n\n__webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n\nfunction isPath(path) {\n  return path.indexOf('.') >= 0;\n}\n\nfunction root(path) {\n  var dotIndex = path.indexOf('.');\n  if (dotIndex === -1) {\n    return path;\n  }\n  return path.slice(0, dotIndex);\n}\n\nfunction isAncestor(base, path) {\n  //     base.startsWith(path + '.');\n  return base.indexOf(path + '.') === 0;\n}\n\nfunction isDescendant(base, path) {\n  //     path.startsWith(base + '.');\n  return path.indexOf(base + '.') === 0;\n}\n\nfunction translate(base, newBase, path) {\n  return newBase + path.slice(base.length);\n}\n\nfunction matches(base, path) {\n  return base === path || isAncestor(base, path) || isDescendant(base, path);\n}\n\nfunction normalize(path) {\n  if (Array.isArray(path)) {\n    var parts = [];\n    for (var i = 0; i < path.length; i++) {\n      var args = path[i].toString().split('.');\n      for (var j = 0; j < args.length; j++) {\n        parts.push(args[j]);\n      }\n    }\n    return parts.join('.');\n  } else {\n    return path;\n  }\n}\n\nfunction split(path) {\n  if (Array.isArray(path)) {\n    return normalize(path).split('.');\n  }\n  return path.toString().split('.');\n}\n\nfunction get(root, path, info) {\n  var prop = root;\n  var parts = split(path);\n  // Loop over path parts[0..n-1] and dereference\n  for (var i = 0; i < parts.length; i++) {\n    if (!prop) {\n      return;\n    }\n    var part = parts[i];\n    prop = prop[part];\n  }\n  if (info) {\n    info.path = parts.join('.');\n  }\n  return prop;\n}\n\nfunction set(root, path, value) {\n  var prop = root;\n  var parts = split(path);\n  var last = parts[parts.length - 1];\n  if (parts.length > 1) {\n    // Loop over path parts[0..n-2] and dereference\n    for (var i = 0; i < parts.length - 1; i++) {\n      var part = parts[i];\n      prop = prop[part];\n      if (!prop) {\n        return;\n      }\n    }\n    // Set value to object at end of path\n    prop[last] = value;\n  } else {\n    // Simple property set\n    prop[path] = value;\n  }\n  return parts.join('.');\n}\n\nvar isDeep = exports.isDeep = isPath;\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/utils/path.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/resolve-url.js":
/*!****************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/resolve-url.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pathFromUrl = exports.resolveUrl = exports.resolveCss = undefined;\n\n__webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n\nvar CSS_URL_RX = /(url\\()([^)]*)(\\))/g;\nvar ABS_URL = /(^\\/)|(^#)|(^[\\w-\\d]*:)/;\nvar workingURL = void 0;\nvar resolveDoc = void 0;\n/**\n * Resolves the given URL against the provided `baseUri'.\n * \n * Note that this function performs no resolution for URLs that start\n * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose\n * URL resolution, use `window.URL`.\n *\n * @memberof Polymer.ResolveUrl\n * @param {string} url Input URL to resolve\n * @param {?string=} baseURI Base URI to resolve the URL against\n * @return {string} resolved URL\n */\nfunction resolveUrl(url, baseURI) {\n  if (url && ABS_URL.test(url)) {\n    return url;\n  }\n  // Lazy feature detection.\n  if (workingURL === undefined) {\n    workingURL = false;\n    try {\n      var u = new URL('b', 'http://a');\n      u.pathname = 'c%20d';\n      workingURL = u.href === 'http://a/c%20d';\n    } catch (e) {\n      // silently fail\n    }\n  }\n  if (!baseURI) {\n    baseURI = document.baseURI || window.location.href;\n  }\n  if (workingURL) {\n    return new URL(url, baseURI).href;\n  }\n  // Fallback to creating an anchor into a disconnected document.\n  if (!resolveDoc) {\n    resolveDoc = document.implementation.createHTMLDocument('temp');\n    resolveDoc.base = resolveDoc.createElement('base');\n    resolveDoc.head.appendChild(resolveDoc.base);\n    resolveDoc.anchor = resolveDoc.createElement('a');\n    resolveDoc.body.appendChild(resolveDoc.anchor);\n  }\n  resolveDoc.base.href = baseURI;\n  resolveDoc.anchor.href = url;\n  return resolveDoc.anchor.href || url;\n}\n\n/**\n * Resolves any relative URL's in the given CSS text against the provided\n * `ownerDocument`'s `baseURI`.\n *\n * @memberof Polymer.ResolveUrl\n * @param {string} cssText CSS text to process\n * @param {string} baseURI Base URI to resolve the URL against\n * @return {string} Processed CSS text with resolved URL's\n */\nfunction resolveCss(cssText, baseURI) {\n  return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {\n    return pre + '\\'' + resolveUrl(url.replace(/[\"']/g, ''), baseURI) + '\\'' + post;\n  });\n}\n\n/**\n * Returns a path from a given `url`. The path includes the trailing\n * `/` from the url.\n *\n * @memberof Polymer.ResolveUrl\n * @param {string} url Input URL to transform\n * @return {string} resolved path\n */\nfunction pathFromUrl(url) {\n  return url.substring(0, url.lastIndexOf('/') + 1);\n}\n\nexports.resolveCss = resolveCss;\nexports.resolveUrl = resolveUrl;\nexports.pathFromUrl = pathFromUrl;\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/utils/resolve-url.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/settings.js":
/*!*************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/settings.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setPassiveTouchGestures = exports.passiveTouchGestures = exports.setSanitizeDOMValue = exports.sanitizeDOMValue = exports.setRootPath = exports.rootPath = exports.useNativeCustomElements = exports.useNativeCSSProperties = exports.useShadow = undefined;\n\n__webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n\nvar _resolveUrl = __webpack_require__(/*! ./resolve-url.js */ \"./node_modules/@polymer/polymer/lib/utils/resolve-url.js\");\n\nvar useShadow = exports.useShadow = !window.ShadyDOM;\nvar useNativeCSSProperties = exports.useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);\nvar useNativeCustomElements = exports.useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;\n\n/**\n * Globally settable property that is automatically assigned to\n * `Polymer.ElementMixin` instances, useful for binding in templates to\n * make URL's relative to an application's root.  Defaults to the main\n * document URL, but can be overridden by users.  It may be useful to set\n * `Polymer.rootPath` to provide a stable application mount path when\n * using client side routing.\n *\n * @memberof Polymer\n */\nvar rootPath = undefined || (0, _resolveUrl.pathFromUrl)(document.baseURI || window.location.href);\n\nexports.rootPath = rootPath;\nvar setRootPath = exports.setRootPath = function setRootPath(path) {\n  exports.rootPath = rootPath = path;\n};\n\n/**\n * A global callback used to sanitize any value before inserting it into the DOM. The callback signature is:\n *\n *     Polymer = {\n *       sanitizeDOMValue: function(value, name, type, node) { ... }\n *     }\n *\n * Where:\n *\n * `value` is the value to sanitize.\n * `name` is the name of an attribute or property (for example, href).\n * `type` indicates where the value is being inserted: one of property, attribute, or text.\n * `node` is the node where the value is being inserted.\n *\n * @type {(function(*,string,string,Node):*)|undefined}\n * @memberof Polymer\n */\nvar sanitizeDOMValue = undefined;\n\nexports.sanitizeDOMValue = sanitizeDOMValue;\nvar setSanitizeDOMValue = exports.setSanitizeDOMValue = function setSanitizeDOMValue(newSanitizeDOMValue) {\n  exports.sanitizeDOMValue = sanitizeDOMValue = newSanitizeDOMValue;\n};\n\n/**\n * Globally settable property to make Polymer Gestures use passive TouchEvent listeners when recognizing gestures.\n * When set to `true`, gestures made from touch will not be able to prevent scrolling, allowing for smoother\n * scrolling performance.\n * Defaults to `false` for backwards compatibility.\n *\n * @memberof Polymer\n */\nvar passiveTouchGestures = false;\n\nexports.passiveTouchGestures = passiveTouchGestures;\nvar setPassiveTouchGestures = exports.setPassiveTouchGestures = function setPassiveTouchGestures(usePassive) {\n  exports.passiveTouchGestures = passiveTouchGestures = usePassive;\n};\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/utils/settings.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/style-gather.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/style-gather.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stylesFromModules = stylesFromModules;\nexports.stylesFromModule = stylesFromModule;\nexports.stylesFromTemplate = stylesFromTemplate;\nexports.stylesFromModuleImports = stylesFromModuleImports;\nexports._stylesFromModuleImports = _stylesFromModuleImports;\nexports.cssFromModules = cssFromModules;\nexports.cssFromModule = cssFromModule;\nexports.cssFromTemplate = cssFromTemplate;\nexports.cssFromModuleImports = cssFromModuleImports;\nexports._cssFromModuleImports = _cssFromModuleImports;\n\nvar _resolveUrl = __webpack_require__(/*! ./resolve-url.js */ \"./node_modules/@polymer/polymer/lib/utils/resolve-url.js\");\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';\nvar INCLUDE_ATTR = 'include';\nvar SHADY_UNSCOPED_ATTR = 'shady-unscoped';\n\nfunction importModule(moduleId) {\n  var /** Polymer.DomModule */PolymerDomModule = customElements.get('dom-module');\n  if (!PolymerDomModule) {\n    return null;\n  }\n  return PolymerDomModule.import(moduleId);\n}\n\nfunction styleForImport(importDoc) {\n  // NOTE: polyfill affordance.\n  // under the HTMLImports polyfill, there will be no 'body',\n  // but the import pseudo-doc can be used directly.\n  var container = importDoc.body ? importDoc.body : importDoc;\n  var importCss = (0, _resolveUrl.resolveCss)(container.textContent, importDoc.baseURI);\n  var style = document.createElement('style');\n  style.textContent = importCss;\n  return style;\n}\n\n/** @typedef {{assetpath: string}} */\nvar templateWithAssetPath = void 0; // eslint-disable-line no-unused-vars\n\nfunction stylesFromModules(moduleIds) {\n  var modules = moduleIds.trim().split(/\\s+/);\n  var styles = [];\n  for (var i = 0; i < modules.length; i++) {\n    styles.push.apply(styles, _toConsumableArray(stylesFromModule(modules[i])));\n  }\n  return styles;\n}\n\nfunction stylesFromModule(moduleId) {\n  var m = importModule(moduleId);\n\n  if (!m) {\n    console.warn('Could not find style data in module named', moduleId);\n    return [];\n  }\n\n  if (m._styles === undefined) {\n    var styles = [];\n    // module imports: <link rel=\"import\" type=\"css\">\n    styles.push.apply(styles, _toConsumableArray(_stylesFromModuleImports(m)));\n    // include css from the first template in the module\n    var template = m.querySelector('template');\n    if (template) {\n      styles.push.apply(styles, _toConsumableArray(stylesFromTemplate(template,\n      /** @type {templateWithAssetPath} */m.assetpath)));\n    }\n\n    m._styles = styles;\n  }\n\n  return m._styles;\n}\n\nfunction stylesFromTemplate(template, baseURI) {\n  if (!template._styles) {\n    var styles = [];\n    // if element is a template, get content from its .content\n    var e$ = template.content.querySelectorAll('style');\n    for (var i = 0; i < e$.length; i++) {\n      var e = e$[i];\n      // support style sharing by allowing styles to \"include\"\n      // other dom-modules that contain styling\n      var include = e.getAttribute(INCLUDE_ATTR);\n      if (include) {\n        styles.push.apply(styles, _toConsumableArray(stylesFromModules(include).filter(function (item, index, self) {\n          return self.indexOf(item) === index;\n        })));\n      }\n      if (baseURI) {\n        e.textContent = (0, _resolveUrl.resolveCss)(e.textContent, baseURI);\n      }\n      styles.push(e);\n    }\n    template._styles = styles;\n  }\n  return template._styles;\n}\n\nfunction stylesFromModuleImports(moduleId) {\n  var m = importModule(moduleId);\n  return m ? _stylesFromModuleImports(m) : [];\n}\n\nfunction _stylesFromModuleImports(module) {\n  var styles = [];\n  var p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);\n  for (var i = 0; i < p$.length; i++) {\n    var p = p$[i];\n    if (p.import) {\n      var importDoc = p.import;\n      var unscoped = p.hasAttribute(SHADY_UNSCOPED_ATTR);\n      if (unscoped && !importDoc._unscopedStyle) {\n        var style = styleForImport(importDoc);\n        style.setAttribute(SHADY_UNSCOPED_ATTR, '');\n        importDoc._unscopedStyle = style;\n      } else if (!importDoc._style) {\n        importDoc._style = styleForImport(importDoc);\n      }\n      styles.push(unscoped ? importDoc._unscopedStyle : importDoc._style);\n    }\n  }\n  return styles;\n}\n\nfunction cssFromModules(moduleIds) {\n  var modules = moduleIds.trim().split(/\\s+/);\n  var cssText = '';\n  for (var i = 0; i < modules.length; i++) {\n    cssText += cssFromModule(modules[i]);\n  }\n  return cssText;\n}\n\nfunction cssFromModule(moduleId) {\n  var m = importModule(moduleId);\n  if (m && m._cssText === undefined) {\n    // module imports: <link rel=\"import\" type=\"css\">\n    var cssText = _cssFromModuleImports(m);\n    // include css from the first template in the module\n    var t = m.querySelector('template');\n    if (t) {\n      cssText += cssFromTemplate(t,\n      /** @type {templateWithAssetPath} */m.assetpath);\n    }\n    m._cssText = cssText || null;\n  }\n  if (!m) {\n    console.warn('Could not find style data in module named', moduleId);\n  }\n  return m && m._cssText || '';\n}\n\nfunction cssFromTemplate(template, baseURI) {\n  var cssText = '';\n  var e$ = stylesFromTemplate(template, baseURI);\n  // if element is a template, get content from its .content\n  for (var i = 0; i < e$.length; i++) {\n    var e = e$[i];\n    if (e.parentNode) {\n      e.parentNode.removeChild(e);\n    }\n    cssText += e.textContent;\n  }\n  return cssText;\n}\n\nfunction cssFromModuleImports(moduleId) {\n  var m = importModule(moduleId);\n  return m ? _cssFromModuleImports(m) : '';\n}\n\nfunction _cssFromModuleImports(module) {\n  var cssText = '';\n  var styles = _stylesFromModuleImports(module);\n  for (var i = 0; i < styles.length; i++) {\n    cssText += styles[i].textContent;\n  }\n  return cssText;\n}\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/utils/style-gather.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/templatize.js":
/*!***************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/templatize.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TemplateInstanceBase = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nexports.templatize = templatize;\nexports.modelForElement = modelForElement;\n\n__webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n\nvar _propertyEffects = __webpack_require__(/*! ../mixins/property-effects.js */ \"./node_modules/@polymer/polymer/lib/mixins/property-effects.js\");\n\nvar _mutableData = __webpack_require__(/*! ../mixins/mutable-data.js */ \"./node_modules/@polymer/polymer/lib/mixins/mutable-data.js\");\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Base class for HTMLTemplateElement extension that has property effects\n// machinery for propagating host properties to children. This is an ES5\n// class only because Babel (incorrectly) requires super() in the class\n// constructor even though no `this` is used and it returns an instance.\nvar newInstance = null;\n/**\n * @constructor\n * @extends {HTMLTemplateElement}\n */\nfunction HTMLTemplateElementExtension() {\n  return newInstance;\n}\nHTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {\n  constructor: {\n    value: HTMLTemplateElementExtension,\n    writable: true\n  }\n});\n/**\n * @constructor\n * @implements {Polymer_PropertyEffects}\n * @extends {HTMLTemplateElementExtension}\n */\nvar DataTemplate = (0, _propertyEffects.PropertyEffects)(HTMLTemplateElementExtension);\n/**\n * @constructor\n * @implements {Polymer_MutableData}\n * @extends {DataTemplate}\n */\nvar MutableDataTemplate = (0, _mutableData.MutableData)(DataTemplate);\n\n// Applies a DataTemplate subclass to a <template> instance\nfunction upgradeTemplate(template, constructor) {\n  newInstance = template;\n  Object.setPrototypeOf(template, constructor.prototype);\n  new constructor();\n  newInstance = null;\n}\n\n// Base class for TemplateInstance's\n/**\n * @constructor\n * @implements {Polymer_PropertyEffects}\n */\nvar base = (0, _propertyEffects.PropertyEffects)(function () {\n  function _class() {\n    _classCallCheck(this, _class);\n  }\n\n  return _class;\n}());\n\n/**\n * @polymer\n * @customElement\n * @appliesMixin Polymer.PropertyEffects\n * @unrestricted\n */\n\nvar TemplateInstanceBase = function (_base) {\n  _inherits(TemplateInstanceBase, _base);\n\n  function TemplateInstanceBase(props) {\n    _classCallCheck(this, TemplateInstanceBase);\n\n    var _this = _possibleConstructorReturn(this, (TemplateInstanceBase.__proto__ || Object.getPrototypeOf(TemplateInstanceBase)).call(this));\n\n    _this._configureProperties(props);\n    _this.root = _this._stampTemplate(_this.__dataHost);\n    // Save list of stamped children\n    var children = _this.children = [];\n    for (var n = _this.root.firstChild; n; n = n.nextSibling) {\n      children.push(n);\n      n.__templatizeInstance = _this;\n    }\n    if (_this.__templatizeOwner && _this.__templatizeOwner.__hideTemplateChildren__) {\n      _this._showHideChildren(true);\n    }\n    // Flush props only when props are passed if instance props exist\n    // or when there isn't instance props.\n    var options = _this.__templatizeOptions;\n    if (props && options.instanceProps || !options.instanceProps) {\n      _this._enableProperties();\n    }\n    return _this;\n  }\n  /**\n   * Configure the given `props` by calling `_setPendingProperty`. Also\n   * sets any properties stored in `__hostProps`.\n   * @private\n   * @param {Object} props Object of property name-value pairs to set.\n   * @return {void}\n   */\n\n\n  _createClass(TemplateInstanceBase, [{\n    key: '_configureProperties',\n    value: function _configureProperties(props) {\n      var options = this.__templatizeOptions;\n      if (options.forwardHostProp) {\n        for (var hprop in this.__hostProps) {\n          this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);\n        }\n      }\n      // Any instance props passed in the constructor will overwrite host props;\n      // normally this would be a user error but we don't specifically filter them\n      for (var iprop in props) {\n        this._setPendingProperty(iprop, props[iprop]);\n      }\n    }\n    /**\n     * Forwards a host property to this instance.  This method should be\n     * called on instances from the `options.forwardHostProp` callback\n     * to propagate changes of host properties to each instance.\n     *\n     * Note this method enqueues the change, which are flushed as a batch.\n     *\n     * @param {string} prop Property or path name\n     * @param {*} value Value of the property to forward\n     * @return {void}\n     */\n\n  }, {\n    key: 'forwardHostProp',\n    value: function forwardHostProp(prop, value) {\n      if (this._setPendingPropertyOrPath(prop, value, false, true)) {\n        this.__dataHost._enqueueClient(this);\n      }\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!Node} node Node to add event listener to\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to add\n     * @return {void}\n     */\n\n  }, {\n    key: '_addEventListenerToNode',\n    value: function _addEventListenerToNode(node, eventName, handler) {\n      var _this2 = this;\n\n      if (this._methodHost && this.__templatizeOptions.parentModel) {\n        // If this instance should be considered a parent model, decorate\n        // events this template instance as `model`\n        this._methodHost._addEventListenerToNode(node, eventName, function (e) {\n          e.model = _this2;\n          handler(e);\n        });\n      } else {\n        // Otherwise delegate to the template's host (which could be)\n        // another template instance\n        var templateHost = this.__dataHost.__dataHost;\n        if (templateHost) {\n          templateHost._addEventListenerToNode(node, eventName, handler);\n        }\n      }\n    }\n    /**\n     * Shows or hides the template instance top level child elements. For\n     * text nodes, `textContent` is removed while \"hidden\" and replaced when\n     * \"shown.\"\n     * @param {boolean} hide Set to true to hide the children;\n     * set to false to show them.\n     * @return {void}\n     * @protected\n     */\n\n  }, {\n    key: '_showHideChildren',\n    value: function _showHideChildren(hide) {\n      var c = this.children;\n      for (var i = 0; i < c.length; i++) {\n        var n = c[i];\n        // Ignore non-changes\n        if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {\n          if (n.nodeType === Node.TEXT_NODE) {\n            if (hide) {\n              n.__polymerTextContent__ = n.textContent;\n              n.textContent = '';\n            } else {\n              n.textContent = n.__polymerTextContent__;\n            }\n            // remove and replace slot\n          } else if (n.localName === 'slot') {\n            if (hide) {\n              n.__polymerReplaced__ = document.createComment('hidden-slot');\n              n.parentNode.replaceChild(n.__polymerReplaced__, n);\n            } else {\n              var replace = n.__polymerReplaced__;\n              if (replace) {\n                replace.parentNode.replaceChild(n, replace);\n              }\n            }\n          } else if (n.style) {\n            if (hide) {\n              n.__polymerDisplay__ = n.style.display;\n              n.style.display = 'none';\n            } else {\n              n.style.display = n.__polymerDisplay__;\n            }\n          }\n        }\n        n.__hideTemplateChildren__ = hide;\n        if (n._showHideChildren) {\n          n._showHideChildren(hide);\n        }\n      }\n    }\n    /**\n     * Overrides default property-effects implementation to intercept\n     * textContent bindings while children are \"hidden\" and cache in\n     * private storage for later retrieval.\n     *\n     * @param {!Node} node The node to set a property on\n     * @param {string} prop The property to set\n     * @param {*} value The value to set\n     * @return {void}\n     * @protected\n     */\n\n  }, {\n    key: '_setUnmanagedPropertyToNode',\n    value: function _setUnmanagedPropertyToNode(node, prop, value) {\n      if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == 'textContent') {\n        node.__polymerTextContent__ = value;\n      } else {\n        _get(TemplateInstanceBase.prototype.__proto__ || Object.getPrototypeOf(TemplateInstanceBase.prototype), '_setUnmanagedPropertyToNode', this).call(this, node, prop, value);\n      }\n    }\n    /**\n     * Find the parent model of this template instance.  The parent model\n     * is either another templatize instance that had option `parentModel: true`,\n     * or else the host element.\n     *\n     * @return {!Polymer_PropertyEffects} The parent model of this instance\n     */\n\n  }, {\n    key: 'dispatchEvent',\n\n\n    /**\n     * Stub of HTMLElement's `dispatchEvent`, so that effects that may\n     * dispatch events safely no-op.\n     *\n     * @param {Event} event Event to dispatch\n     * @return {boolean} Always true.\n     */\n    value: function dispatchEvent(event) {\n      // eslint-disable-line no-unused-vars\n      return true;\n    }\n  }, {\n    key: 'parentModel',\n    get: function get() {\n      var model = this.__parentModel;\n      if (!model) {\n        var options = void 0;\n        model = this;\n        do {\n          // A template instance's `__dataHost` is a <template>\n          // `model.__dataHost.__dataHost` is the template's host\n          model = model.__dataHost.__dataHost;\n        } while ((options = model.__templatizeOptions) && !options.parentModel);\n        this.__parentModel = model;\n      }\n      return model;\n    }\n  }]);\n\n  return TemplateInstanceBase;\n}(base);\n\n/** @type {!DataTemplate} */\n\n\nTemplateInstanceBase.prototype.__dataHost;\n/** @type {!TemplatizeOptions} */\nTemplateInstanceBase.prototype.__templatizeOptions;\n/** @type {!Polymer_PropertyEffects} */\nTemplateInstanceBase.prototype._methodHost;\n/** @type {!Object} */\nTemplateInstanceBase.prototype.__templatizeOwner;\n/** @type {!Object} */\nTemplateInstanceBase.prototype.__hostProps;\n\n/**\n * @constructor\n * @extends {TemplateInstanceBase}\n * @implements {Polymer_MutableData}\n */\nvar MutableTemplateInstanceBase = (0, _mutableData.MutableData)(TemplateInstanceBase);\n\nfunction findMethodHost(template) {\n  // Technically this should be the owner of the outermost template.\n  // In shadow dom, this is always getRootNode().host, but we can\n  // approximate this via cooperation with our dataHost always setting\n  // `_methodHost` as long as there were bindings (or id's) on this\n  // instance causing it to get a dataHost.\n  var templateHost = template.__dataHost;\n  return templateHost && templateHost._methodHost || templateHost;\n}\n\n/* eslint-disable valid-jsdoc */\n/**\n * @suppress {missingProperties} class.prototype is not defined for some reason\n */\nfunction createTemplatizerClass(template, templateInfo, options) {\n  // Anonymous class created by the templatize\n  var base = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase;\n  /**\n   * @constructor\n   * @extends {base}\n   * @private\n   */\n  var klass = function (_base2) {\n    _inherits(klass, _base2);\n\n    function klass() {\n      _classCallCheck(this, klass);\n\n      return _possibleConstructorReturn(this, (klass.__proto__ || Object.getPrototypeOf(klass)).apply(this, arguments));\n    }\n\n    return klass;\n  }(base);\n  klass.prototype.__templatizeOptions = options;\n  klass.prototype._bindTemplate(template);\n  addNotifyEffects(klass, template, templateInfo, options);\n  return klass;\n}\n\n/**\n * @suppress {missingProperties} class.prototype is not defined for some reason\n */\nfunction addPropagateEffects(template, templateInfo, options) {\n  var userForwardHostProp = options.forwardHostProp;\n  if (userForwardHostProp) {\n    // Provide data API and property effects on memoized template class\n    var klass = templateInfo.templatizeTemplateClass;\n    if (!klass) {\n      var _base3 = options.mutableData ? MutableDataTemplate : DataTemplate;\n      klass = templateInfo.templatizeTemplateClass = function (_base4) {\n        _inherits(TemplatizedTemplate, _base4);\n\n        function TemplatizedTemplate() {\n          _classCallCheck(this, TemplatizedTemplate);\n\n          return _possibleConstructorReturn(this, (TemplatizedTemplate.__proto__ || Object.getPrototypeOf(TemplatizedTemplate)).apply(this, arguments));\n        }\n\n        return TemplatizedTemplate;\n      }(_base3);\n      // Add template - >instances effects\n      // and host <- template effects\n      var hostProps = templateInfo.hostProps;\n      for (var prop in hostProps) {\n        klass.prototype._addPropertyEffect('_host_' + prop, klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE, { fn: createForwardHostPropEffect(prop, userForwardHostProp) });\n        klass.prototype._createNotifyingProperty('_host_' + prop);\n      }\n    }\n    upgradeTemplate(template, klass);\n    // Mix any pre-bound data into __data; no need to flush this to\n    // instances since they pull from the template at instance-time\n    if (template.__dataProto) {\n      // Note, generally `__dataProto` could be chained, but it's guaranteed\n      // to not be since this is a vanilla template we just added effects to\n      Object.assign(template.__data, template.__dataProto);\n    }\n    // Clear any pending data for performance\n    template.__dataTemp = {};\n    template.__dataPending = null;\n    template.__dataOld = null;\n    template._enableProperties();\n  }\n}\n/* eslint-enable valid-jsdoc */\n\nfunction createForwardHostPropEffect(hostProp, userForwardHostProp) {\n  return function forwardHostProp(template, prop, props) {\n    userForwardHostProp.call(template.__templatizeOwner, prop.substring('_host_'.length), props[prop]);\n  };\n}\n\nfunction addNotifyEffects(klass, template, templateInfo, options) {\n  var hostProps = templateInfo.hostProps || {};\n  for (var iprop in options.instanceProps) {\n    delete hostProps[iprop];\n    var userNotifyInstanceProp = options.notifyInstanceProp;\n    if (userNotifyInstanceProp) {\n      klass.prototype._addPropertyEffect(iprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp) });\n    }\n  }\n  if (options.forwardHostProp && template.__dataHost) {\n    for (var hprop in hostProps) {\n      klass.prototype._addPropertyEffect(hprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyHostPropEffect() });\n    }\n  }\n}\n\nfunction createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {\n  return function notifyInstanceProp(inst, prop, props) {\n    userNotifyInstanceProp.call(inst.__templatizeOwner, inst, prop, props[prop]);\n  };\n}\n\nfunction createNotifyHostPropEffect() {\n  return function notifyHostProp(inst, prop, props) {\n    inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);\n  };\n}\n\nfunction templatize(template, owner, options) {\n  options = /** @type {!TemplatizeOptions} */options || {};\n  if (template.__templatizeOwner) {\n    throw new Error('A <template> can only be templatized once');\n  }\n  template.__templatizeOwner = owner;\n  var ctor = owner ? owner.constructor : TemplateInstanceBase;\n  var templateInfo = ctor._parseTemplate(template);\n  // Get memoized base class for the prototypical template, which\n  // includes property effects for binding template & forwarding\n  var baseClass = templateInfo.templatizeInstanceClass;\n  if (!baseClass) {\n    baseClass = createTemplatizerClass(template, templateInfo, options);\n    templateInfo.templatizeInstanceClass = baseClass;\n  }\n  // Host property forwarding must be installed onto template instance\n  addPropagateEffects(template, templateInfo, options);\n  // Subclass base class and add reference for this specific template\n  /** @private */\n  var klass = function (_baseClass) {\n    _inherits(TemplateInstance, _baseClass);\n\n    function TemplateInstance() {\n      _classCallCheck(this, TemplateInstance);\n\n      return _possibleConstructorReturn(this, (TemplateInstance.__proto__ || Object.getPrototypeOf(TemplateInstance)).apply(this, arguments));\n    }\n\n    return TemplateInstance;\n  }(baseClass);\n  klass.prototype._methodHost = findMethodHost(template);\n  klass.prototype.__dataHost = template;\n  klass.prototype.__templatizeOwner = owner;\n  klass.prototype.__hostProps = templateInfo.hostProps;\n  klass = /** @type {function(new:TemplateInstanceBase)} */klass; //eslint-disable-line no-self-assign\n  return klass;\n}\n\nfunction modelForElement(template, node) {\n  var model = void 0;\n  while (node) {\n    // An element with a __templatizeInstance marks the top boundary\n    // of a scope; walk up until we find one, and then ensure that\n    // its __dataHost matches `this`, meaning this dom-repeat stamped it\n    if (model = node.__templatizeInstance) {\n      // Found an element stamped by another template; keep walking up\n      // from its __dataHost\n      if (model.__dataHost != template) {\n        node = model.__dataHost;\n      } else {\n        return model;\n      }\n    } else {\n      // Still in a template scope, keep going up until\n      // a __templatizeInstance is found\n      node = node.parentNode;\n    }\n  }\n  return null;\n}\n\nexports.TemplateInstanceBase = TemplateInstanceBase;\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/lib/utils/templatize.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/polymer-element.js":
/*!**********************************************************!*\
  !*** ./node_modules/@polymer/polymer/polymer-element.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.html = exports.PolymerElement = undefined;\n\nvar _elementMixin = __webpack_require__(/*! ./lib/mixins/element-mixin.js */ \"./node_modules/@polymer/polymer/lib/mixins/element-mixin.js\");\n\nvar _htmlTag = __webpack_require__(/*! ./lib/utils/html-tag.js */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n\n/**\n * Base class that provides the core API for Polymer's meta-programming\n * features including template stamping, data-binding, attribute deserialization,\n * and property change observation.\n *\n * @customElement\n * @polymer\n * @memberof Polymer\n * @constructor\n * @implements {Polymer_ElementMixin}\n * @extends HTMLElement\n * @appliesMixin Polymer.ElementMixin\n * @summary Custom element base class that provides the core API for Polymer's\n *   key meta-programming features including template stamping, data-binding,\n *   attribute deserialization, and property change observation\n */\nvar Element = (0, _elementMixin.ElementMixin)(HTMLElement);\nexports.PolymerElement = Element;\nexports.html = _htmlTag.html;\n\n//# sourceURL=webpack:///./node_modules/@polymer/polymer/polymer-element.js?");

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./lib/axios */ \"./node_modules/axios/lib/axios.js\");\n\n//# sourceURL=webpack:///./node_modules/axios/index.js?");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar settle = __webpack_require__(/*! ./../core/settle */ \"./node_modules/axios/lib/core/settle.js\");\nvar buildURL = __webpack_require__(/*! ./../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\nvar parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ \"./node_modules/axios/lib/helpers/parseHeaders.js\");\nvar isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ \"./node_modules/axios/lib/helpers/isURLSameOrigin.js\");\nvar createError = __webpack_require__(/*! ../core/createError */ \"./node_modules/axios/lib/core/createError.js\");\nvar btoa = typeof window !== 'undefined' && window.btoa && window.btoa.bind(window) || __webpack_require__(/*! ./../helpers/btoa */ \"./node_modules/axios/lib/helpers/btoa.js\");\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n    var loadEvent = 'onreadystatechange';\n    var xDomain = false;\n\n    // For IE 8/9 CORS support\n    // Only supports POST and GET calls and doesn't returns the response headers.\n    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.\n    if (\"development\" !== 'test' && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {\n      request = new window.XDomainRequest();\n      loadEvent = 'onload';\n      xDomain = true;\n      request.onprogress = function handleProgress() {};\n      request.ontimeout = function handleTimeout() {};\n    }\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request[loadEvent] = function handleLoad() {\n      if (!request || request.readyState !== 4 && !xDomain) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)\n        status: request.status === 1223 ? 204 : request.status,\n        statusText: request.status === 1223 ? 'No Content' : request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      var cookies = __webpack_require__(/*! ./../helpers/cookies */ \"./node_modules/axios/lib/helpers/cookies.js\");\n\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (config.withCredentials) {\n      request.withCredentials = true;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/adapters/xhr.js?");

/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\nvar Axios = __webpack_require__(/*! ./core/Axios */ \"./node_modules/axios/lib/core/Axios.js\");\nvar defaults = __webpack_require__(/*! ./defaults */ \"./node_modules/axios/lib/defaults.js\");\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(utils.merge(defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\naxios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ \"./node_modules/axios/lib/cancel/CancelToken.js\");\naxios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(/*! ./helpers/spread */ \"./node_modules/axios/lib/helpers/spread.js\");\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n\n//# sourceURL=webpack:///./node_modules/axios/lib/axios.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\n\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n\n//# sourceURL=webpack:///./node_modules/axios/lib/cancel/Cancel.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Cancel = __webpack_require__(/*! ./Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n//# sourceURL=webpack:///./node_modules/axios/lib/cancel/CancelToken.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/cancel/isCancel.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar defaults = __webpack_require__(/*! ./../defaults */ \"./node_modules/axios/lib/defaults.js\");\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ \"./node_modules/axios/lib/core/InterceptorManager.js\");\nvar dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ \"./node_modules/axios/lib/core/dispatchRequest.js\");\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = utils.merge({\n      url: arguments[0]\n    }, arguments[1]);\n  }\n\n  config = utils.merge(defaults, { method: 'get' }, this.defaults, config);\n  config.method = config.method.toLowerCase();\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function (url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function (url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/Axios.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/InterceptorManager.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar enhanceError = __webpack_require__(/*! ./enhanceError */ \"./node_modules/axios/lib/core/enhanceError.js\");\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/createError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar transformData = __webpack_require__(/*! ./transformData */ \"./node_modules/axios/lib/core/transformData.js\");\nvar isCancel = __webpack_require__(/*! ../cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\nvar defaults = __webpack_require__(/*! ../defaults */ \"./node_modules/axios/lib/defaults.js\");\nvar isAbsoluteURL = __webpack_require__(/*! ./../helpers/isAbsoluteURL */ \"./node_modules/axios/lib/helpers/isAbsoluteURL.js\");\nvar combineURLs = __webpack_require__(/*! ./../helpers/combineURLs */ \"./node_modules/axios/lib/helpers/combineURLs.js\");\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Support baseURL config\n  if (config.baseURL && !isAbsoluteURL(config.url)) {\n    config.url = combineURLs(config.baseURL, config.url);\n  }\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(config.data, config.headers, config.transformRequest);\n\n  // Flatten headers\n  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});\n\n  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {\n    delete config.headers[method];\n  });\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(response.data, response.headers, config.transformResponse);\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/dispatchRequest.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\n\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n  error.request = request;\n  error.response = response;\n  return error;\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/enhanceError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar createError = __webpack_require__(/*! ./createError */ \"./node_modules/axios/lib/core/createError.js\");\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  // Note: status is not exposed by XDomainRequest\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/settle.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/transformData.js?");

/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\nvar normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ \"./node_modules/axios/lib/helpers/normalizeHeaderName.js\");\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(/*! ./adapters/xhr */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  } else if (typeof process !== 'undefined') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(/*! ./adapters/http */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) {/* Ignore */}\n    }\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/axios/lib/defaults.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/bind.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/btoa.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/btoa.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js\n\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction E() {\n  this.message = 'String contains an invalid character';\n}\nE.prototype = new Error();\nE.prototype.code = 5;\nE.prototype.name = 'InvalidCharacterError';\n\nfunction btoa(input) {\n  var str = String(input);\n  var output = '';\n  for (\n  // initialize result and counter\n  var block, charCode, idx = 0, map = chars;\n  // if the next str index does not exist:\n  //   change the mapping table to \"=\"\n  //   check if d has no fractional digits\n  str.charAt(idx | 0) || (map = '=', idx % 1);\n  // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {\n    charCode = str.charCodeAt(idx += 3 / 4);\n    if (charCode > 0xFF) {\n      throw new E();\n    }\n    block = block << 8 | charCode;\n  }\n  return output;\n}\n\nmodule.exports = btoa;\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/btoa.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction encode(val) {\n  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/buildURL.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\n\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '') : baseURL;\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/combineURLs.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = utils.isStandardBrowserEnv() ?\n\n// Standard browser envs support document.cookie\nfunction standardBrowserEnv() {\n  return {\n    write: function write(name, value, expires, path, domain, secure) {\n      var cookie = [];\n      cookie.push(name + '=' + encodeURIComponent(value));\n\n      if (utils.isNumber(expires)) {\n        cookie.push('expires=' + new Date(expires).toGMTString());\n      }\n\n      if (utils.isString(path)) {\n        cookie.push('path=' + path);\n      }\n\n      if (utils.isString(domain)) {\n        cookie.push('domain=' + domain);\n      }\n\n      if (secure === true) {\n        cookie.push('secure');\n      }\n\n      document.cookie = cookie.join('; ');\n    },\n\n    read: function read(name) {\n      var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n      return match ? decodeURIComponent(match[3]) : null;\n    },\n\n    remove: function remove(name) {\n      this.write(name, '', Date.now() - 86400000);\n    }\n  };\n}() :\n\n// Non standard browser env (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n  return {\n    write: function write() {},\n    read: function read() {\n      return null;\n    },\n    remove: function remove() {}\n  };\n}();\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/cookies.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\n\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return (/^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url)\n  );\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/isAbsoluteURL.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = utils.isStandardBrowserEnv() ?\n\n// Standard browser envs have full support of the APIs needed to test\n// whether the request URL is of the same origin as current location.\nfunction standardBrowserEnv() {\n  var msie = /(msie|trident)/i.test(navigator.userAgent);\n  var urlParsingNode = document.createElement('a');\n  var originURL;\n\n  /**\n  * Parse a URL to discover it's components\n  *\n  * @param {String} url The URL to be parsed\n  * @returns {Object}\n  */\n  function resolveURL(url) {\n    var href = url;\n\n    if (msie) {\n      // IE needs attribute set twice to normalize properties\n      urlParsingNode.setAttribute('href', href);\n      href = urlParsingNode.href;\n    }\n\n    urlParsingNode.setAttribute('href', href);\n\n    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n    return {\n      href: urlParsingNode.href,\n      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n      host: urlParsingNode.host,\n      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n      hostname: urlParsingNode.hostname,\n      port: urlParsingNode.port,\n      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname\n    };\n  }\n\n  originURL = resolveURL(window.location.href);\n\n  /**\n  * Determine if a URL shares the same origin as the current location\n  *\n  * @param {String} requestURL The URL to test\n  * @returns {boolean} True if URL shares the same origin, otherwise false\n  */\n  return function isURLSameOrigin(requestURL) {\n    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;\n    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;\n  };\n}() :\n\n// Non standard browser envs (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n  return function isURLSameOrigin() {\n    return true;\n  };\n}();\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/isURLSameOrigin.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/normalizeHeaderName.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) {\n    return parsed;\n  }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/parseHeaders.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\n\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/spread.js?");

/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\nvar isBuffer = __webpack_require__(/*! is-buffer */ \"./node_modules/is-buffer/index.js\");\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return typeof FormData !== 'undefined' && val instanceof FormData;\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = val && val.buffer && val.buffer instanceof ArrayBuffer;\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object';\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return false;\n  }\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge() /* obj1, obj2, obj3, ... */{\n  var result = {};\n  function assignValue(val, key) {\n    if (_typeof(result[key]) === 'object' && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/utils.js?");

/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);\n};\n\nfunction isBuffer(obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer(obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));\n}\n\n//# sourceURL=webpack:///./node_modules/is-buffer/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n    return [];\n};\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./src/components/containers/admin-app/index.js":
/*!******************************************************!*\
  !*** ./src/components/containers/admin-app/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _polymerElement = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n\nvar _axios = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n\nvar _axios2 = _interopRequireDefault(_axios);\n\nvar _style = __webpack_require__(/*! ./style.pcss */ \"./src/components/containers/admin-app/style.pcss\");\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _template = __webpack_require__(/*! ./template.html */ \"./src/components/containers/admin-app/template.html\");\n\nvar _template2 = _interopRequireDefault(_template);\n\n__webpack_require__(/*! ../../dumbs/app-header */ \"./src/components/dumbs/app-header/index.js\");\n\n__webpack_require__(/*! ../../dumbs/projects-table-admin */ \"./src/components/dumbs/projects-table-admin/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar AdminApp = function (_PolymerElement) {\n  _inherits(AdminApp, _PolymerElement);\n\n  _createClass(AdminApp, null, [{\n    key: 'properties',\n    get: function get() {\n      return {\n        data: {\n          type: Array,\n          value: []\n        }\n      };\n    }\n  }, {\n    key: 'template',\n    get: function get() {\n      return (0, _polymerElement.html)(['<style>' + _style2.default + '</style> ' + _template2.default]);\n    }\n  }]);\n\n  function AdminApp() {\n    _classCallCheck(this, AdminApp);\n\n    var _this = _possibleConstructorReturn(this, (AdminApp.__proto__ || Object.getPrototypeOf(AdminApp)).call(this));\n\n    _this.updateData();\n    return _this;\n  }\n\n  _createClass(AdminApp, [{\n    key: 'updateData',\n    value: function updateData() {\n      var _this2 = this;\n\n      _axios2.default.get('/projects', { timeout: 100000 }).then(function (data) {\n        return _this2.data = data.data;\n      }).catch(function (err) {\n        return console.log(err);\n      });\n    }\n  }]);\n\n  return AdminApp;\n}(_polymerElement.PolymerElement);\n\nexports.default = AdminApp;\n\n\nwindow.customElements.define('admin-app', AdminApp);\n\n//# sourceURL=webpack:///./src/components/containers/admin-app/index.js?");

/***/ }),

/***/ "./src/components/containers/admin-app/style.pcss":
/*!********************************************************!*\
  !*** ./src/components/containers/admin-app/style.pcss ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"\"\n\n//# sourceURL=webpack:///./src/components/containers/admin-app/style.pcss?");

/***/ }),

/***/ "./src/components/containers/admin-app/template.html":
/*!***********************************************************!*\
  !*** ./src/components/containers/admin-app/template.html ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<section class=\\\"alumno-app\\\">\\r\\n  <app-header title=\\\"Admin\\\"></app-header>\\r\\n  <projects-table-admin data =\\\"{{data}}\\\"></projects-table-admin>\\r\\n</section>\"\n\n//# sourceURL=webpack:///./src/components/containers/admin-app/template.html?");

/***/ }),

/***/ "./src/components/containers/alumno-app/index.js":
/*!*******************************************************!*\
  !*** ./src/components/containers/alumno-app/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _polymerElement = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n\nvar _axios = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n\nvar _axios2 = _interopRequireDefault(_axios);\n\nvar _style = __webpack_require__(/*! ./style.pcss */ \"./src/components/containers/alumno-app/style.pcss\");\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _template = __webpack_require__(/*! ./template.html */ \"./src/components/containers/alumno-app/template.html\");\n\nvar _template2 = _interopRequireDefault(_template);\n\n__webpack_require__(/*! ../../dumbs/app-header */ \"./src/components/dumbs/app-header/index.js\");\n\n__webpack_require__(/*! ../../dumbs/bind-input */ \"./src/components/dumbs/bind-input/index.js\");\n\n__webpack_require__(/*! ../../dumbs/projects-table-alumno */ \"./src/components/dumbs/projects-table-alumno/index.js\");\n\n__webpack_require__(/*! ../../dumbs/news-container */ \"./src/components/dumbs/news-container/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar AlumnoApp = function (_PolymerElement) {\n  _inherits(AlumnoApp, _PolymerElement);\n\n  function AlumnoApp() {\n    _classCallCheck(this, AlumnoApp);\n\n    return _possibleConstructorReturn(this, (AlumnoApp.__proto__ || Object.getPrototypeOf(AlumnoApp)).apply(this, arguments));\n  }\n\n  _createClass(AlumnoApp, [{\n    key: 'searchChange',\n    value: function searchChange(newValue) {\n      var _this2 = this;\n\n      _axios2.default.get('/projects/' + newValue, { timeout: 100000 }).then(function (data) {\n        return _this2.data = data.data;\n      }).catch(function (err) {\n        return console.log(err);\n      });\n    }\n  }], [{\n    key: 'properties',\n    get: function get() {\n      return {\n        search: {\n          type: String,\n          value: \"\"\n        },\n        data: {\n          type: Array,\n          value: []\n        }\n      };\n    }\n  }, {\n    key: 'observers',\n    get: function get() {\n      return ['searchChange(search)'];\n    }\n  }, {\n    key: 'template',\n    get: function get() {\n      return (0, _polymerElement.html)(['<style>' + _style2.default + '</style> ' + _template2.default]);\n    }\n  }]);\n\n  return AlumnoApp;\n}(_polymerElement.PolymerElement);\n\nexports.default = AlumnoApp;\n\n\nwindow.customElements.define('alumno-app', AlumnoApp);\n\n//# sourceURL=webpack:///./src/components/containers/alumno-app/index.js?");

/***/ }),

/***/ "./src/components/containers/alumno-app/style.pcss":
/*!*********************************************************!*\
  !*** ./src/components/containers/alumno-app/style.pcss ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \".search-input{position:relative;display:block;overflow:hidden;margin:3rem 25%;width:50%}\"\n\n//# sourceURL=webpack:///./src/components/containers/alumno-app/style.pcss?");

/***/ }),

/***/ "./src/components/containers/alumno-app/template.html":
/*!************************************************************!*\
  !*** ./src/components/containers/alumno-app/template.html ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<section class=\\\"alumno-app\\\">\\r\\n  <app-header title=\\\"Alumno\\\"></app-header>\\r\\n  <bind-input value=\\\"{{search}}\\\" placeholder=\\\"Buscar...\\\" bind-style=\\\"width: calc(100% - 2px - 4em);height: 3em;padding: 0 2em;border-radius: 1em;\\\" type=\\\"text\\\" class=\\\"search-input\\\"></bind-input>\\r\\n  <projects-table-alumno data =\\\"[[data]]\\\"></projects-table-alumno>\\r\\n  <news-container style=\\\"margin-top: 2em;\\\"></news-container>\\r\\n</section>\"\n\n//# sourceURL=webpack:///./src/components/containers/alumno-app/template.html?");

/***/ }),

/***/ "./src/components/containers/profesor-app/index.js":
/*!*********************************************************!*\
  !*** ./src/components/containers/profesor-app/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _polymerElement = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n\nvar _axios = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n\nvar _axios2 = _interopRequireDefault(_axios);\n\nvar _style = __webpack_require__(/*! ./style.pcss */ \"./src/components/containers/profesor-app/style.pcss\");\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _template = __webpack_require__(/*! ./template.html */ \"./src/components/containers/profesor-app/template.html\");\n\nvar _template2 = _interopRequireDefault(_template);\n\n__webpack_require__(/*! ../../dumbs/app-header */ \"./src/components/dumbs/app-header/index.js\");\n\n__webpack_require__(/*! ../../dumbs/add-proyecto-form */ \"./src/components/dumbs/add-proyecto-form/index.js\");\n\n__webpack_require__(/*! ../../dumbs/projects-table-profesor */ \"./src/components/dumbs/projects-table-profesor/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ProfesorApp = function (_PolymerElement) {\n  _inherits(ProfesorApp, _PolymerElement);\n\n  _createClass(ProfesorApp, null, [{\n    key: 'template',\n    get: function get() {\n      return (0, _polymerElement.html)(['<style>' + _style2.default + '</style> ' + _template2.default]);\n    }\n  }]);\n\n  function ProfesorApp() {\n    _classCallCheck(this, ProfesorApp);\n\n    var _this = _possibleConstructorReturn(this, (ProfesorApp.__proto__ || Object.getPrototypeOf(ProfesorApp)).call(this));\n\n    _this.data = [];\n    _this.updateData();\n    return _this;\n  }\n\n  _createClass(ProfesorApp, [{\n    key: 'updateData',\n    value: function updateData() {\n      var _this2 = this;\n\n      _axios2.default.get('/projects', { timeout: 100000 }).then(function (data) {\n        return _this2.data = data.data;\n      }).catch(function (err) {\n        return console.log(err);\n      });\n    }\n  }]);\n\n  return ProfesorApp;\n}(_polymerElement.PolymerElement);\n\nexports.default = ProfesorApp;\n\n\nwindow.customElements.define('profesor-app', ProfesorApp);\n\n//# sourceURL=webpack:///./src/components/containers/profesor-app/index.js?");

/***/ }),

/***/ "./src/components/containers/profesor-app/style.pcss":
/*!***********************************************************!*\
  !*** ./src/components/containers/profesor-app/style.pcss ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \".search-input{position:relative;display:block;overflow:hidden;margin:3rem 25%;width:50%}\"\n\n//# sourceURL=webpack:///./src/components/containers/profesor-app/style.pcss?");

/***/ }),

/***/ "./src/components/containers/profesor-app/template.html":
/*!**************************************************************!*\
  !*** ./src/components/containers/profesor-app/template.html ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<section class=\\\"alumno-app\\\">\\r\\n  <app-header title=\\\"Profesor\\\"></app-header>\\r\\n  <add-proyecto-form data=\\\"{{data}}\\\"></add-proyecto-form>\\r\\n  <projects-table-profesor data =\\\"[[data]]\\\"></projects-table-profesor>\\r\\n</section>\"\n\n//# sourceURL=webpack:///./src/components/containers/profesor-app/template.html?");

/***/ }),

/***/ "./src/components/dumbs/add-proyecto-form/index.js":
/*!*********************************************************!*\
  !*** ./src/components/dumbs/add-proyecto-form/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _polymerElement = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n\n__webpack_require__(/*! @polymer/polymer/lib/elements/dom-if.js */ \"./node_modules/@polymer/polymer/lib/elements/dom-if.js\");\n\nvar _axios = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n\nvar _axios2 = _interopRequireDefault(_axios);\n\nvar _style = __webpack_require__(/*! ./style.pcss */ \"./src/components/dumbs/add-proyecto-form/style.pcss\");\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _template = __webpack_require__(/*! ./template.html */ \"./src/components/dumbs/add-proyecto-form/template.html\");\n\nvar _template2 = _interopRequireDefault(_template);\n\n__webpack_require__(/*! ../bind-input */ \"./src/components/dumbs/bind-input/index.js\");\n\n__webpack_require__(/*! ../bind-text-area */ \"./src/components/dumbs/bind-text-area/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar AddProyectoForm = function (_PolymerElement) {\n  _inherits(AddProyectoForm, _PolymerElement);\n\n  _createClass(AddProyectoForm, null, [{\n    key: 'properties',\n    get: function get() {\n      return {\n        data: {\n          type: Array,\n          value: \"\",\n          notify: true\n        }\n      };\n    }\n  }, {\n    key: 'template',\n    get: function get() {\n      return (0, _polymerElement.html)(['<style>' + _style2.default + '</style> ' + _template2.default]);\n    }\n  }]);\n\n  function AddProyectoForm() {\n    _classCallCheck(this, AddProyectoForm);\n\n    var _this = _possibleConstructorReturn(this, (AddProyectoForm.__proto__ || Object.getPrototypeOf(AddProyectoForm)).call(this));\n\n    _this.title = \"\";\n    _this.description = \"\";\n    _this.supervisor = \"\";\n\n    _this.errorTitle = \"\";\n    _this.errorDescription = \"\";\n    _this.errorSupervisor = \"\";\n\n    _this.addMessage = \"\";\n    return _this;\n  }\n\n  _createClass(AddProyectoForm, [{\n    key: 'handleSubmit',\n    value: function handleSubmit(e) {\n      var _this2 = this;\n\n      e.preventDefault();\n      this.errorTitle = \"\";\n      this.errorDescription = \"\";\n      this.errorSupervisor = \"\";\n      this.addMessage = \"\";\n      if (!this.title) {\n        this.errorTitle = \"Campo vacio\";\n        return;\n      }\n      if (!this.description) {\n        this.errorDescription = \"Campo vacio\";\n        return;\n      }\n      if (!this.supervisor) {\n        this.errorSupervisor = \"Campo vacio\";\n        return;\n      }\n      _axios2.default.post('./projects', { title: this.title, description: this.description, supervisor: this.supervisor }, { timeout: 100000 }).then(function (data) {\n        _this2.title = \"\";\n        _this2.description = \"\";\n        _this2.supervisor = \"\";\n        _this2.addMessage = \"Proyecto añadido\";\n        _axios2.default.get('/projects', { timeout: 100000 }).then(function (data) {\n          return _this2.data = data.data;\n        }).catch(function (err) {\n          return console.log(err);\n        });\n      }).catch(function (err) {\n        return console.log(err);\n      });\n    }\n  }]);\n\n  return AddProyectoForm;\n}(_polymerElement.PolymerElement);\n\nexports.default = AddProyectoForm;\n\n\nwindow.customElements.define('add-proyecto-form', AddProyectoForm);\n\n//# sourceURL=webpack:///./src/components/dumbs/add-proyecto-form/index.js?");

/***/ }),

/***/ "./src/components/dumbs/add-proyecto-form/style.pcss":
/*!***********************************************************!*\
  !*** ./src/components/dumbs/add-proyecto-form/style.pcss ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \":host{display:block;overflow:hidden;padding:2em 20%}.input,:host{position:relative}.input{padding-top:1em;width:100%}.input label{display:inline-block;width:100%}input{margin-top:1em}\"\n\n//# sourceURL=webpack:///./src/components/dumbs/add-proyecto-form/style.pcss?");

/***/ }),

/***/ "./src/components/dumbs/add-proyecto-form/template.html":
/*!**************************************************************!*\
  !*** ./src/components/dumbs/add-proyecto-form/template.html ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<h1>Añadir proyecto</h1>\\r\\n<form on-submit=\\\"handleSubmit\\\">\\r\\n  <div class=\\\"input\\\">\\r\\n    <label for=\\\"dni\\\">Título:</label>\\r\\n    <bind-input value=\\\"{{title}}\\\" placeholder=\\\"Título...\\\" type=\\\"text\\\" bind-style=\\\"width: 100%;\\\"></bind-input>\\r\\n  </div>\\r\\n  <p>{{errorTitle}}</p>\\r\\n  <div class=\\\"input\\\" style=\\\"width: 100%;\\\">\\r\\n    <label for=\\\"dni\\\">Descripción:</label>\\r\\n    <bind-text-area value=\\\"{{description}}\\\" placeholder=\\\"Descripción...\\\" bind-style=\\\"width: 100%;\\\"></bind-text-area>\\r\\n  </div>\\r\\n  <p>{{errorDescription}}</p>\\r\\n  <div class=\\\"input\\\">\\r\\n    <label for=\\\"dni\\\">Supervisor:</label>\\r\\n    <bind-input value=\\\"{{supervisor}}\\\" placeholder=\\\"Supervisor...\\\" type=\\\"text\\\" bind-style=\\\"width: 100%;\\\"></bind-input>\\r\\n  </div>\\r\\n  <p>{{errorSupervisor}}</p>\\r\\n  <input type=\\\"submit\\\" value=\\\"Añadir proyecto\\\">\\r\\n  <p>{{addMessage}}</p>\\r\\n</form>\"\n\n//# sourceURL=webpack:///./src/components/dumbs/add-proyecto-form/template.html?");

/***/ }),

/***/ "./src/components/dumbs/app-header/index.js":
/*!**************************************************!*\
  !*** ./src/components/dumbs/app-header/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _polymerElement = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n\nvar _style = __webpack_require__(/*! ./style.pcss */ \"./src/components/dumbs/app-header/style.pcss\");\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _template = __webpack_require__(/*! ./template.html */ \"./src/components/dumbs/app-header/template.html\");\n\nvar _template2 = _interopRequireDefault(_template);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar AppHeader = function (_PolymerElement) {\n  _inherits(AppHeader, _PolymerElement);\n\n  function AppHeader() {\n    _classCallCheck(this, AppHeader);\n\n    return _possibleConstructorReturn(this, (AppHeader.__proto__ || Object.getPrototypeOf(AppHeader)).apply(this, arguments));\n  }\n\n  _createClass(AppHeader, null, [{\n    key: 'properties',\n    get: function get() {\n      return {\n        title: {\n          type: String\n        }\n      };\n    }\n  }, {\n    key: 'template',\n    get: function get() {\n      return (0, _polymerElement.html)(['<style>' + _style2.default + '</style> ' + _template2.default]);\n    }\n  }]);\n\n  return AppHeader;\n}(_polymerElement.PolymerElement);\n\nexports.default = AppHeader;\n\n\nwindow.customElements.define('app-header', AppHeader);\n\n//# sourceURL=webpack:///./src/components/dumbs/app-header/index.js?");

/***/ }),

/***/ "./src/components/dumbs/app-header/style.pcss":
/*!****************************************************!*\
  !*** ./src/components/dumbs/app-header/style.pcss ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"a,a:visited{color:#fff;text-decoration:none;font-weight:700;-webkit-transition:color .2s;transition:color .2s}p{font-size:1em;color:#fff;line-height:1.8;font-weight:200}body,html{display:block;position:relative;margin:0;width:100%}body{overflow-x:hidden;overflow-y:auto}.app-header{text-align:center;background:#1690c0;padding:1rem;color:#fff}.app-header h1{font-size:50px;margin:0}\"\n\n//# sourceURL=webpack:///./src/components/dumbs/app-header/style.pcss?");

/***/ }),

/***/ "./src/components/dumbs/app-header/template.html":
/*!*******************************************************!*\
  !*** ./src/components/dumbs/app-header/template.html ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<div class=\\\"app-header\\\">\\r\\n  <h1>[[title]]</h1>\\r\\n</div>\"\n\n//# sourceURL=webpack:///./src/components/dumbs/app-header/template.html?");

/***/ }),

/***/ "./src/components/dumbs/asignar-proyecto-form/index.js":
/*!*************************************************************!*\
  !*** ./src/components/dumbs/asignar-proyecto-form/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _polymerElement = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n\n__webpack_require__(/*! @polymer/polymer/lib/elements/dom-if.js */ \"./node_modules/@polymer/polymer/lib/elements/dom-if.js\");\n\nvar _axios = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n\nvar _axios2 = _interopRequireDefault(_axios);\n\nvar _style = __webpack_require__(/*! ./style.pcss */ \"./src/components/dumbs/asignar-proyecto-form/style.pcss\");\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _template = __webpack_require__(/*! ./template.html */ \"./src/components/dumbs/asignar-proyecto-form/template.html\");\n\nvar _template2 = _interopRequireDefault(_template);\n\n__webpack_require__(/*! ../bind-input */ \"./src/components/dumbs/bind-input/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar AsignarProyectoForm = function (_PolymerElement) {\n  _inherits(AsignarProyectoForm, _PolymerElement);\n\n  _createClass(AsignarProyectoForm, null, [{\n    key: 'properties',\n    get: function get() {\n      return {\n        data: {\n          type: Array,\n          value: \"\",\n          notify: true\n        },\n        projectId: {\n          type: Number,\n          required: true\n        }\n      };\n    }\n  }, {\n    key: 'template',\n    get: function get() {\n      return (0, _polymerElement.html)(['<style>' + _style2.default + '</style> ' + _template2.default]);\n    }\n  }]);\n\n  function AsignarProyectoForm() {\n    _classCallCheck(this, AsignarProyectoForm);\n\n    var _this = _possibleConstructorReturn(this, (AsignarProyectoForm.__proto__ || Object.getPrototypeOf(AsignarProyectoForm)).call(this));\n\n    _this.alumnoId = 1;\n    _this.completed = false;\n    _this.errorMessage = \"\";\n    return _this;\n  }\n\n  _createClass(AsignarProyectoForm, [{\n    key: 'handleSubmit',\n    value: function handleSubmit(e) {\n      var _this2 = this;\n\n      e.preventDefault();\n      this.errorMessage = \"\";\n      if (!this.alumnoId) {\n        this.errorMessage = \"Campo vacío\";\n        return;\n      }\n      _axios2.default.get('./asignar/' + this.projectId + '/' + this.alumnoId, { timeout: 100000 }).then(function (data) {\n        _this2.completed = true;\n        _axios2.default.get('/projects', { timeout: 100000 }).then(function (data) {\n          return _this2.data = data.data;\n        }).catch(function (err) {\n          return function (err) {\n            return console.log(err);\n          };\n        });\n      }).catch(function (err) {\n        return console.log(err);\n      });\n    }\n  }]);\n\n  return AsignarProyectoForm;\n}(_polymerElement.PolymerElement);\n\nexports.default = AsignarProyectoForm;\n\n\nwindow.customElements.define('asignar-proyecto-form', AsignarProyectoForm);\n\n//# sourceURL=webpack:///./src/components/dumbs/asignar-proyecto-form/index.js?");

/***/ }),

/***/ "./src/components/dumbs/asignar-proyecto-form/style.pcss":
/*!***************************************************************!*\
  !*** ./src/components/dumbs/asignar-proyecto-form/style.pcss ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"\"\n\n//# sourceURL=webpack:///./src/components/dumbs/asignar-proyecto-form/style.pcss?");

/***/ }),

/***/ "./src/components/dumbs/asignar-proyecto-form/template.html":
/*!******************************************************************!*\
  !*** ./src/components/dumbs/asignar-proyecto-form/template.html ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template is=\\\"dom-if\\\" if=\\\"{{!completed}}\\\">\\r\\n  <form on-submit=\\\"handleSubmit\\\" >\\r\\n    <label for=\\\"dni\\\">Id del alumno:</label>\\r\\n    <bind-input value=\\\"{{alumnoId}}\\\" placeholder=\\\"Id de alumno...\\\" type=\\\"number\\\"></bind-input>\\r\\n    <input type=\\\"submit\\\" value=\\\"Asignar proyecto\\\">\\r\\n    {{errorMessage}}\\r\\n  </form>\\r\\n</template>\\r\\n<template is=\\\"dom-if\\\" if=\\\"{{completed}}\\\">\\r\\n  Proyecto asignado.\\r\\n</template>\"\n\n//# sourceURL=webpack:///./src/components/dumbs/asignar-proyecto-form/template.html?");

/***/ }),

/***/ "./src/components/dumbs/bind-input/index.js":
/*!**************************************************!*\
  !*** ./src/components/dumbs/bind-input/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _polymerElement = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n\nvar _style = __webpack_require__(/*! ./style.pcss */ \"./src/components/dumbs/bind-input/style.pcss\");\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _template = __webpack_require__(/*! ./template.html */ \"./src/components/dumbs/bind-input/template.html\");\n\nvar _template2 = _interopRequireDefault(_template);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar BindInput = function (_PolymerElement) {\n  _inherits(BindInput, _PolymerElement);\n\n  function BindInput() {\n    _classCallCheck(this, BindInput);\n\n    return _possibleConstructorReturn(this, (BindInput.__proto__ || Object.getPrototypeOf(BindInput)).apply(this, arguments));\n  }\n\n  _createClass(BindInput, [{\n    key: 'handleChange',\n    value: function handleChange(e) {\n      this.value = e.target.value;\n    }\n  }], [{\n    key: 'properties',\n    get: function get() {\n      return {\n        value: {\n          type: String,\n          required: true,\n          notify: true\n        },\n        placeholder: {\n          type: String,\n          value: \"\"\n        },\n        type: {\n          type: String,\n          value: \"\"\n        },\n        bindStyle: {\n          type: String,\n          value: \"\"\n        }\n      };\n    }\n  }, {\n    key: 'template',\n    get: function get() {\n      return (0, _polymerElement.html)(['<style>' + _style2.default + '</style> ' + _template2.default]);\n    }\n  }]);\n\n  return BindInput;\n}(_polymerElement.PolymerElement);\n\nexports.default = BindInput;\n\n\nwindow.customElements.define('bind-input', BindInput);\n\n//# sourceURL=webpack:///./src/components/dumbs/bind-input/index.js?");

/***/ }),

/***/ "./src/components/dumbs/bind-input/style.pcss":
/*!****************************************************!*\
  !*** ./src/components/dumbs/bind-input/style.pcss ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"\"\n\n//# sourceURL=webpack:///./src/components/dumbs/bind-input/style.pcss?");

/***/ }),

/***/ "./src/components/dumbs/bind-input/template.html":
/*!*******************************************************!*\
  !*** ./src/components/dumbs/bind-input/template.html ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<input type$=\\\"[[type]]\\\" placeholder$=\\\"[[placeholder]]\\\" value=\\\"{{value}}\\\" style$=\\\"[[bindStyle]]\\\" on-input=\\\"handleChange\\\"></input>\\r\\n\"\n\n//# sourceURL=webpack:///./src/components/dumbs/bind-input/template.html?");

/***/ }),

/***/ "./src/components/dumbs/bind-text-area/index.js":
/*!******************************************************!*\
  !*** ./src/components/dumbs/bind-text-area/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _polymerElement = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n\nvar _style = __webpack_require__(/*! ./style.pcss */ \"./src/components/dumbs/bind-text-area/style.pcss\");\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _template = __webpack_require__(/*! ./template.html */ \"./src/components/dumbs/bind-text-area/template.html\");\n\nvar _template2 = _interopRequireDefault(_template);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar BindTextArea = function (_PolymerElement) {\n  _inherits(BindTextArea, _PolymerElement);\n\n  function BindTextArea() {\n    _classCallCheck(this, BindTextArea);\n\n    return _possibleConstructorReturn(this, (BindTextArea.__proto__ || Object.getPrototypeOf(BindTextArea)).apply(this, arguments));\n  }\n\n  _createClass(BindTextArea, [{\n    key: 'handleChange',\n    value: function handleChange(e) {\n      this.value = e.target.value;\n    }\n  }], [{\n    key: 'properties',\n    get: function get() {\n      return {\n        value: {\n          type: String,\n          required: true,\n          notify: true\n        },\n        placeholder: {\n          type: String,\n          value: \"\"\n        },\n        bindStyle: {\n          type: String,\n          value: \"\"\n        }\n      };\n    }\n  }, {\n    key: 'template',\n    get: function get() {\n      return (0, _polymerElement.html)(['<style>' + _style2.default + '</style> ' + _template2.default]);\n    }\n  }]);\n\n  return BindTextArea;\n}(_polymerElement.PolymerElement);\n\nexports.default = BindTextArea;\n\n\nwindow.customElements.define('bind-text-area', BindTextArea);\n\n//# sourceURL=webpack:///./src/components/dumbs/bind-text-area/index.js?");

/***/ }),

/***/ "./src/components/dumbs/bind-text-area/style.pcss":
/*!********************************************************!*\
  !*** ./src/components/dumbs/bind-text-area/style.pcss ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"\"\n\n//# sourceURL=webpack:///./src/components/dumbs/bind-text-area/style.pcss?");

/***/ }),

/***/ "./src/components/dumbs/bind-text-area/template.html":
/*!***********************************************************!*\
  !*** ./src/components/dumbs/bind-text-area/template.html ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<textarea placeholder$=\\\"[[placeholder]]\\\" value=\\\"{{value}}\\\" style$=\\\"[[bindStyle]]\\\" on-input=\\\"handleChange\\\"></textarea>\\r\\n\"\n\n//# sourceURL=webpack:///./src/components/dumbs/bind-text-area/template.html?");

/***/ }),

/***/ "./src/components/dumbs/news-container/index.js":
/*!******************************************************!*\
  !*** ./src/components/dumbs/news-container/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _polymerElement = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n\n__webpack_require__(/*! @polymer/polymer/lib/elements/dom-repeat.js */ \"./node_modules/@polymer/polymer/lib/elements/dom-repeat.js\");\n\nvar _axios = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n\nvar _axios2 = _interopRequireDefault(_axios);\n\nvar _style = __webpack_require__(/*! ./style.pcss */ \"./src/components/dumbs/news-container/style.pcss\");\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _template = __webpack_require__(/*! ./template.html */ \"./src/components/dumbs/news-container/template.html\");\n\nvar _template2 = _interopRequireDefault(_template);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar NewsContainer = function (_PolymerElement) {\n  _inherits(NewsContainer, _PolymerElement);\n\n  _createClass(NewsContainer, null, [{\n    key: 'template',\n    get: function get() {\n      return (0, _polymerElement.html)(['<style>' + _style2.default + '</style> ' + _template2.default]);\n    }\n  }]);\n\n  function NewsContainer() {\n    _classCallCheck(this, NewsContainer);\n\n    var _this = _possibleConstructorReturn(this, (NewsContainer.__proto__ || Object.getPrototypeOf(NewsContainer)).call(this));\n\n    _this.news = [];\n    _axios2.default.get(\"http://localhost:8080/ProductorConsumidor/GetAll\", { timeout: 100000, responseType: 'text' }).then(function (data) {\n      var res = [];\n      var parser = new DOMParser();\n      var xmlDoc = parser.parseFromString(data.data, \"text/xml\");\n      var xmlData = xmlDoc.getElementsByTagName(\"new\");\n      for (var i = 0; i < xmlData.length; i++) {\n        res.push({\n          desc: xmlData[i].getElementsByTagName(\"desc\")[0].innerHTML,\n          content: xmlData[i].getElementsByTagName(\"content\")[0].innerHTML,\n          date: xmlData[i].getElementsByTagName(\"date\")[0].innerHTML\n        });\n      }\n      _this.news = res;\n    }).catch(function (err) {\n      return console.log(err);\n    });\n    return _this;\n  }\n\n  return NewsContainer;\n}(_polymerElement.PolymerElement);\n\nexports.default = NewsContainer;\n\n\nwindow.customElements.define('news-container', NewsContainer);\n\n//# sourceURL=webpack:///./src/components/dumbs/news-container/index.js?");

/***/ }),

/***/ "./src/components/dumbs/news-container/style.pcss":
/*!********************************************************!*\
  !*** ./src/components/dumbs/news-container/style.pcss ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"\"\n\n//# sourceURL=webpack:///./src/components/dumbs/news-container/style.pcss?");

/***/ }),

/***/ "./src/components/dumbs/news-container/template.html":
/*!***********************************************************!*\
  !*** ./src/components/dumbs/news-container/template.html ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<h1>Noticias</h1>\\r\\n<template is=\\\"dom-repeat\\\" items=\\\"[[news]]\\\">\\r\\n  <hr/>\\r\\n  <h2>[[item.desc]]</h2>\\r\\n  <p>[[item.content]]</p>\\r\\n  <p>[[item.date]]</p>\\r\\n</template>\\r\\n<hr/>\\r\\n\"\n\n//# sourceURL=webpack:///./src/components/dumbs/news-container/template.html?");

/***/ }),

/***/ "./src/components/dumbs/projects-table-admin/index.js":
/*!************************************************************!*\
  !*** ./src/components/dumbs/projects-table-admin/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _polymerElement = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n\n__webpack_require__(/*! @polymer/polymer/lib/elements/dom-repeat.js */ \"./node_modules/@polymer/polymer/lib/elements/dom-repeat.js\");\n\nvar _style = __webpack_require__(/*! ./style.pcss */ \"./src/components/dumbs/projects-table-admin/style.pcss\");\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _template = __webpack_require__(/*! ./template.html */ \"./src/components/dumbs/projects-table-admin/template.html\");\n\nvar _template2 = _interopRequireDefault(_template);\n\n__webpack_require__(/*! ../asignar-proyecto-form */ \"./src/components/dumbs/asignar-proyecto-form/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ProjectsTableAdmin = function (_PolymerElement) {\n  _inherits(ProjectsTableAdmin, _PolymerElement);\n\n  function ProjectsTableAdmin() {\n    _classCallCheck(this, ProjectsTableAdmin);\n\n    return _possibleConstructorReturn(this, (ProjectsTableAdmin.__proto__ || Object.getPrototypeOf(ProjectsTableAdmin)).apply(this, arguments));\n  }\n\n  _createClass(ProjectsTableAdmin, null, [{\n    key: 'properties',\n    get: function get() {\n      return {\n        data: {\n          type: Array,\n          value: \"\",\n          notify: true\n        }\n      };\n    }\n  }, {\n    key: 'template',\n    get: function get() {\n      return (0, _polymerElement.html)(['<style>' + _style2.default + '</style> ' + _template2.default]);\n    }\n  }]);\n\n  return ProjectsTableAdmin;\n}(_polymerElement.PolymerElement);\n\nexports.default = ProjectsTableAdmin;\n\n\nwindow.customElements.define('projects-table-admin', ProjectsTableAdmin);\n\n//# sourceURL=webpack:///./src/components/dumbs/projects-table-admin/index.js?");

/***/ }),

/***/ "./src/components/dumbs/projects-table-admin/style.pcss":
/*!**************************************************************!*\
  !*** ./src/components/dumbs/projects-table-admin/style.pcss ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \":host table{font-family:arial,sans-serif;border-collapse:collapse;width:100%}:host td,:host th{border:1px solid #ddd;text-align:left;padding:8px}:host tr:nth-child(2n){background-color:#ddd}\"\n\n//# sourceURL=webpack:///./src/components/dumbs/projects-table-admin/style.pcss?");

/***/ }),

/***/ "./src/components/dumbs/projects-table-admin/template.html":
/*!*****************************************************************!*\
  !*** ./src/components/dumbs/projects-table-admin/template.html ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<table>\\r\\n  <tr>\\r\\n    <th>Título</th>\\r\\n    <th>Descripción</th>\\r\\n    <th>Supervisor</th>\\r\\n    <th>Alumnos interesados</th>\\r\\n    <th>Alumno asignado</th>\\r\\n  </tr>\\r\\n  <template is=\\\"dom-repeat\\\" items=\\\"[[data]]\\\">\\r\\n    <tr class=\\\"item\\\">\\r\\n      <td>[[item.title]]</td>\\r\\n      <td>[[item.description]]</td>\\r\\n      <td>[[item.supervisor]]</td>\\r\\n      <td>[[item.interestedStudents]]</td>\\r\\n      <td>[[item.assignedStudent]]</td>\\r\\n    </tr>\\r\\n    <tr>\\r\\n      <td colspan=\\\"5\\\">\\r\\n        <asignar-proyecto-form project-id=\\\"[[item.id]]\\\" data={{data}}></asignar-proyecto-form>\\r\\n      </td>\\r\\n    </tr>\\r\\n  </template>\\r\\n</table>\"\n\n//# sourceURL=webpack:///./src/components/dumbs/projects-table-admin/template.html?");

/***/ }),

/***/ "./src/components/dumbs/projects-table-alumno/index.js":
/*!*************************************************************!*\
  !*** ./src/components/dumbs/projects-table-alumno/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _polymerElement = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n\n__webpack_require__(/*! @polymer/polymer/lib/elements/dom-repeat.js */ \"./node_modules/@polymer/polymer/lib/elements/dom-repeat.js\");\n\nvar _style = __webpack_require__(/*! ./style.pcss */ \"./src/components/dumbs/projects-table-alumno/style.pcss\");\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _template = __webpack_require__(/*! ./template.html */ \"./src/components/dumbs/projects-table-alumno/template.html\");\n\nvar _template2 = _interopRequireDefault(_template);\n\n__webpack_require__(/*! ../solicitar-interes-form */ \"./src/components/dumbs/solicitar-interes-form/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ProjectsTableAlumno = function (_PolymerElement) {\n  _inherits(ProjectsTableAlumno, _PolymerElement);\n\n  function ProjectsTableAlumno() {\n    _classCallCheck(this, ProjectsTableAlumno);\n\n    return _possibleConstructorReturn(this, (ProjectsTableAlumno.__proto__ || Object.getPrototypeOf(ProjectsTableAlumno)).apply(this, arguments));\n  }\n\n  _createClass(ProjectsTableAlumno, null, [{\n    key: 'properties',\n    get: function get() {\n      return {\n        data: {\n          type: Array,\n          value: \"\"\n        }\n      };\n    }\n  }, {\n    key: 'template',\n    get: function get() {\n      return (0, _polymerElement.html)(['<style>' + _style2.default + '</style> ' + _template2.default]);\n    }\n  }]);\n\n  return ProjectsTableAlumno;\n}(_polymerElement.PolymerElement);\n\nexports.default = ProjectsTableAlumno;\n\n\nwindow.customElements.define('projects-table-alumno', ProjectsTableAlumno);\n\n//# sourceURL=webpack:///./src/components/dumbs/projects-table-alumno/index.js?");

/***/ }),

/***/ "./src/components/dumbs/projects-table-alumno/style.pcss":
/*!***************************************************************!*\
  !*** ./src/components/dumbs/projects-table-alumno/style.pcss ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \":host table{font-family:arial,sans-serif;border-collapse:collapse;width:100%}:host td,:host th{border:1px solid #ddd;text-align:left;padding:8px}:host tr:nth-child(2n){background-color:#ddd}\"\n\n//# sourceURL=webpack:///./src/components/dumbs/projects-table-alumno/style.pcss?");

/***/ }),

/***/ "./src/components/dumbs/projects-table-alumno/template.html":
/*!******************************************************************!*\
  !*** ./src/components/dumbs/projects-table-alumno/template.html ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<table>\\r\\n  <tr>\\r\\n    <th>Título</th>\\r\\n    <th>Descripción</th>\\r\\n    <th>Supervisor</th>\\r\\n  </tr>\\r\\n  <template is=\\\"dom-repeat\\\" items=\\\"[[data]]\\\">\\r\\n    <tr class=\\\"item\\\">\\r\\n      <td>[[item.title]]</td>\\r\\n      <td>[[item.description]]</td>\\r\\n      <td>[[item.supervisor]]</td>\\r\\n    </tr>\\r\\n    <tr>\\r\\n      <td colspan=\\\"3\\\">\\r\\n        <solicitar-interes-form project-id=\\\"[[item.id]]\\\"></solicitar-interes-form>\\r\\n      </td>\\r\\n    </tr>\\r\\n  </template>\\r\\n</table>\"\n\n//# sourceURL=webpack:///./src/components/dumbs/projects-table-alumno/template.html?");

/***/ }),

/***/ "./src/components/dumbs/projects-table-profesor/index.js":
/*!***************************************************************!*\
  !*** ./src/components/dumbs/projects-table-profesor/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _polymerElement = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n\n__webpack_require__(/*! @polymer/polymer/lib/elements/dom-repeat.js */ \"./node_modules/@polymer/polymer/lib/elements/dom-repeat.js\");\n\nvar _style = __webpack_require__(/*! ./style.pcss */ \"./src/components/dumbs/projects-table-profesor/style.pcss\");\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _template = __webpack_require__(/*! ./template.html */ \"./src/components/dumbs/projects-table-profesor/template.html\");\n\nvar _template2 = _interopRequireDefault(_template);\n\n__webpack_require__(/*! ../solicitar-interes-form */ \"./src/components/dumbs/solicitar-interes-form/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ProjectsTableProfesor = function (_PolymerElement) {\n  _inherits(ProjectsTableProfesor, _PolymerElement);\n\n  function ProjectsTableProfesor() {\n    _classCallCheck(this, ProjectsTableProfesor);\n\n    return _possibleConstructorReturn(this, (ProjectsTableProfesor.__proto__ || Object.getPrototypeOf(ProjectsTableProfesor)).apply(this, arguments));\n  }\n\n  _createClass(ProjectsTableProfesor, null, [{\n    key: 'properties',\n    get: function get() {\n      return {\n        data: {\n          type: Array,\n          value: \"\"\n        }\n      };\n    }\n  }, {\n    key: 'template',\n    get: function get() {\n      return (0, _polymerElement.html)(['<style>' + _style2.default + '</style> ' + _template2.default]);\n    }\n  }]);\n\n  return ProjectsTableProfesor;\n}(_polymerElement.PolymerElement);\n\nexports.default = ProjectsTableProfesor;\n\n\nwindow.customElements.define('projects-table-profesor', ProjectsTableProfesor);\n\n//# sourceURL=webpack:///./src/components/dumbs/projects-table-profesor/index.js?");

/***/ }),

/***/ "./src/components/dumbs/projects-table-profesor/style.pcss":
/*!*****************************************************************!*\
  !*** ./src/components/dumbs/projects-table-profesor/style.pcss ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \":host table{font-family:arial,sans-serif;border-collapse:collapse;width:100%}:host td,:host th{border:1px solid #ddd;text-align:left;padding:8px}:host tr:nth-child(2n){background-color:#ddd}\"\n\n//# sourceURL=webpack:///./src/components/dumbs/projects-table-profesor/style.pcss?");

/***/ }),

/***/ "./src/components/dumbs/projects-table-profesor/template.html":
/*!********************************************************************!*\
  !*** ./src/components/dumbs/projects-table-profesor/template.html ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<table>\\r\\n  <tr>\\r\\n    <th>Título</th>\\r\\n    <th>Descripción</th>\\r\\n    <th>Supervisor</th>\\r\\n  </tr>\\r\\n  <template is=\\\"dom-repeat\\\" items=\\\"[[data]]\\\">\\r\\n    <tr class=\\\"item\\\">\\r\\n      <td>[[item.title]]</td>\\r\\n      <td>[[item.description]]</td>\\r\\n      <td>[[item.supervisor]]</td>\\r\\n    </tr>\\r\\n  </template>\\r\\n</table>\"\n\n//# sourceURL=webpack:///./src/components/dumbs/projects-table-profesor/template.html?");

/***/ }),

/***/ "./src/components/dumbs/solicitar-interes-form/index.js":
/*!**************************************************************!*\
  !*** ./src/components/dumbs/solicitar-interes-form/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _polymerElement = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n\n__webpack_require__(/*! @polymer/polymer/lib/elements/dom-if.js */ \"./node_modules/@polymer/polymer/lib/elements/dom-if.js\");\n\nvar _axios = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n\nvar _axios2 = _interopRequireDefault(_axios);\n\nvar _style = __webpack_require__(/*! ./style.pcss */ \"./src/components/dumbs/solicitar-interes-form/style.pcss\");\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _template = __webpack_require__(/*! ./template.html */ \"./src/components/dumbs/solicitar-interes-form/template.html\");\n\nvar _template2 = _interopRequireDefault(_template);\n\n__webpack_require__(/*! ../bind-input */ \"./src/components/dumbs/bind-input/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar SolicitarInteresForm = function (_PolymerElement) {\n  _inherits(SolicitarInteresForm, _PolymerElement);\n\n  _createClass(SolicitarInteresForm, null, [{\n    key: 'properties',\n    get: function get() {\n      return {\n        data: {\n          type: Array,\n          value: \"\"\n        },\n        projectId: {\n          type: Number,\n          required: true\n        }\n      };\n    }\n  }, {\n    key: 'template',\n    get: function get() {\n      return (0, _polymerElement.html)(['<style>' + _style2.default + '</style> ' + _template2.default]);\n    }\n  }]);\n\n  function SolicitarInteresForm() {\n    _classCallCheck(this, SolicitarInteresForm);\n\n    var _this = _possibleConstructorReturn(this, (SolicitarInteresForm.__proto__ || Object.getPrototypeOf(SolicitarInteresForm)).call(this));\n\n    _this.dni = \"\";\n    _this.completed = false;\n    _this.errorMessage = \"\";\n    return _this;\n  }\n\n  _createClass(SolicitarInteresForm, [{\n    key: 'handleSubmit',\n    value: function handleSubmit(e) {\n      var _this2 = this;\n\n      e.preventDefault();\n      this.errorMessage = \"\";\n      if (!this.dni) {\n        this.errorMessage = \"Campo vacío\";\n        return;\n      }\n      _axios2.default.get('./solicitar/' + this.projectId + '/' + this.dni, { timeout: 100000 }).then(function (data) {\n        return _this2.completed = true;\n      }).catch(function (err) {\n        return function (err) {\n          return console.log(err);\n        };\n      });\n    }\n  }]);\n\n  return SolicitarInteresForm;\n}(_polymerElement.PolymerElement);\n\nexports.default = SolicitarInteresForm;\n\n\nwindow.customElements.define('solicitar-interes-form', SolicitarInteresForm);\n\n//# sourceURL=webpack:///./src/components/dumbs/solicitar-interes-form/index.js?");

/***/ }),

/***/ "./src/components/dumbs/solicitar-interes-form/style.pcss":
/*!****************************************************************!*\
  !*** ./src/components/dumbs/solicitar-interes-form/style.pcss ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"\"\n\n//# sourceURL=webpack:///./src/components/dumbs/solicitar-interes-form/style.pcss?");

/***/ }),

/***/ "./src/components/dumbs/solicitar-interes-form/template.html":
/*!*******************************************************************!*\
  !*** ./src/components/dumbs/solicitar-interes-form/template.html ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template is=\\\"dom-if\\\" if=\\\"{{!completed}}\\\">\\r\\n  <form on-submit=\\\"handleSubmit\\\" >\\r\\n    <label for=\\\"dni\\\">DNI:</label>\\r\\n    <bind-input value=\\\"{{dni}}\\\" placeholder=\\\"DNI...\\\" type=\\\"text\\\"></bind-input>\\r\\n    <input type=\\\"submit\\\" value=\\\"Solicitar proyecto\\\">\\r\\n    {{errorMessage}}\\r\\n  </form>\\r\\n</template>\\r\\n<template is=\\\"dom-if\\\" if=\\\"{{completed}}\\\">\\r\\n  Solicitud enviada.\\r\\n</template>\"\n\n//# sourceURL=webpack:///./src/components/dumbs/solicitar-interes-form/template.html?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* Import WebpackApp */\n\n/* eslint-disable no-unused-vars */\n\n__webpack_require__(/*! ./components/containers/alumno-app */ \"./src/components/containers/alumno-app/index.js\");\n\n__webpack_require__(/*! ./components/containers/profesor-app */ \"./src/components/containers/profesor-app/index.js\");\n\n__webpack_require__(/*! ./components/containers/admin-app */ \"./src/components/containers/admin-app/index.js\");\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });